<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QBTC Scanner ‚Äî Bitcoin Recovery</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:          #020209;
      --surface:     #06060f;
      --surface2:    #0b0b1a;
      --surface3:    #101025;
      --border:      #181835;
      --text:        #c8dcf0;
      --text2:       #4a6080;
      --text3:       #222840;
      --accent:      #00e5ff;
      --accent-dim:  rgba(0,229,255,.07);
      --accent-glow: 0 0 18px rgba(0,229,255,.35);
      --accent2:     #7c3aed;
      --accent2-dim: rgba(124,58,237,.1);
      --success:     #00ff88;
      --success-dim: rgba(0,255,136,.07);
      --danger:      #ff2255;
      --warning:     #ffaa00;
      --r:  10px;
      --rs: 7px;
      --mono: 'SF Mono','Cascadia Code','Fira Code','Consolas',monospace;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
      overflow-x: hidden;
    }

    /* Dot-grid background */
    body::before {
      content: '';
      position: fixed; inset: 0;
      background-image: radial-gradient(rgba(0,229,255,.12) 1px, transparent 1px);
      background-size: 32px 32px;
      pointer-events: none; z-index: 0;
    }

    /* Subtle horizontal scan sweep */
    @keyframes scan { 0%{transform:translateY(-100vh)} 100%{transform:translateY(100vh)} }
    body::after {
      content: '';
      position: fixed; left: 0; right: 0; top: 0; height: 120px;
      background: linear-gradient(180deg, transparent, rgba(0,229,255,.018), transparent);
      pointer-events: none; z-index: 0;
      animation: scan 8s linear infinite;
    }

    header, nav, .container, .toast { position: relative; z-index: 2; }

    /* ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ */
    .header {
      background: rgba(2,2,9,.94);
      backdrop-filter: blur(14px);
      border-bottom: 1px solid var(--border);
      padding: 13px 18px;
      display: flex; align-items: center; justify-content: space-between;
      position: sticky; top: 0; z-index: 10;
    }
    .header::after {
      content: '';
      position: absolute; bottom: -1px; left: 0; right: 0; height: 1px;
      background: linear-gradient(90deg, transparent 0%, var(--accent) 50%, transparent 100%);
      opacity: .25;
    }
    .header-brand { display: flex; align-items: center; gap: 12px; }
    .header-logo {
      font-size: 28px;
      animation: glow-logo 3s ease-in-out infinite;
      display: inline-block;
    }
    @keyframes glow-logo {
      0%,100% { filter: drop-shadow(0 0 6px rgba(0,229,255,.5)); }
      50%      { filter: drop-shadow(0 0 18px rgba(0,229,255,1)) drop-shadow(0 0 40px rgba(0,229,255,.4)); }
    }
    .header-title {
      font-size: 17px; font-weight: 800; letter-spacing: 3px;
      font-family: var(--mono);
      color: var(--accent);
      text-shadow: 0 0 14px rgba(0,229,255,.55);
    }
    .header-sub { font-size: 10.5px; color: var(--text2); letter-spacing: .6px; margin-top: 1px; }
    .header-right { display: flex; align-items: center; gap: 8px; }
    .badge {
      display: inline-flex; align-items: center; gap: 5px;
      padding: 4px 11px; border-radius: 100px;
      font-size: 11px; font-weight: 600; font-family: var(--mono);
    }
    .badge-idle { background: var(--surface2); color: var(--text2); border: 1px solid var(--border); }
    .badge-run  { background: rgba(0,229,255,.07); color: var(--accent); border: 1px solid rgba(0,229,255,.3); box-shadow: 0 0 10px rgba(0,229,255,.12); }
    .pulse { display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: var(--accent); box-shadow: 0 0 6px var(--accent); animation: blink 1s ease-in-out infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.15} }

    /* ‚îÄ‚îÄ‚îÄ STATS BAR ‚îÄ‚îÄ‚îÄ */
    .stats-bar {
      display: grid; grid-template-columns: repeat(4, 1fr);
      gap: 1px; background: var(--border);
      border-bottom: 1px solid var(--border);
    }
    .stat { background: var(--surface); padding: 11px 8px; text-align: center; }
    .stat-val {
      font-size: 22px; font-weight: 800; font-family: var(--mono);
      color: var(--accent); font-variant-numeric: tabular-nums;
      text-shadow: 0 0 10px rgba(0,229,255,.4);
    }
    .stat-lbl { font-size: 9px; color: var(--text2); text-transform: uppercase; letter-spacing: .8px; margin-top: 2px; }
    #sFound { color: var(--success); text-shadow: 0 0 10px rgba(0,255,136,.4) !important; }

    /* ‚îÄ‚îÄ‚îÄ TABS ‚îÄ‚îÄ‚îÄ */
    .tabs {
      display: flex; background: rgba(6,6,15,.97);
      border-bottom: 1px solid var(--border);
      position: sticky; top: 56px; z-index: 9;
    }
    .tab {
      flex: 1; padding: 11px 4px;
      font-size: 10.5px; font-weight: 700; letter-spacing: .6px;
      text-align: center; cursor: pointer;
      border: none; background: transparent; color: var(--text2);
      border-bottom: 2px solid transparent;
      transition: all .2s; font-family: var(--mono);
    }
    .tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
      text-shadow: 0 0 10px rgba(0,229,255,.6);
    }
    .tab:hover:not(.active) { color: var(--text); }

    /* ‚îÄ‚îÄ‚îÄ LAYOUT ‚îÄ‚îÄ‚îÄ */
    .container {
      max-width: 820px; margin: 0 auto;
      padding: 18px 12px;
      display: flex; flex-direction: column; gap: 14px;
    }

    /* ‚îÄ‚îÄ‚îÄ CARDS ‚îÄ‚îÄ‚îÄ */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--r);
      padding: 20px;
      position: relative; overflow: hidden;
    }
    .card::before {
      content: '';
      position: absolute; top: 0; left: 10%; right: 10%; height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0,229,255,.18), transparent);
    }
    .card-title {
      font-size: 13px; font-weight: 700; letter-spacing: 1.2px;
      margin-bottom: 16px; font-family: var(--mono);
      color: var(--accent);
      display: flex; align-items: center; gap: 8px;
    }
    .hidden { display: none !important; }

    /* ‚îÄ‚îÄ‚îÄ QUICK GUIDE (collapsible) ‚îÄ‚îÄ‚îÄ */
    .guide {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      overflow: hidden;
      margin-bottom: 16px;
    }
    .guide summary {
      padding: 10px 14px;
      font-size: 12px; font-family: var(--mono);
      color: var(--text2); cursor: pointer;
      user-select: none; list-style: none;
      display: flex; align-items: center; gap: 8px;
    }
    .guide summary::-webkit-details-marker { display: none; }
    .guide summary::before { content: '‚ñ∂'; color: var(--accent2); font-size: 10px; transition: transform .2s; }
    .guide[open] summary::before { transform: rotate(90deg); }
    .guide-body { padding: 0 14px 14px; display: flex; flex-direction: column; gap: 8px; }
    .guide-step {
      display: flex; align-items: flex-start; gap: 12px;
      padding: 10px 12px; background: var(--surface);
      border: 1px solid var(--border); border-radius: var(--rs);
    }
    .guide-num {
      width: 22px; height: 22px; border-radius: 50%; flex-shrink: 0;
      background: rgba(0,229,255,.09); border: 1px solid rgba(0,229,255,.25);
      display: flex; align-items: center; justify-content: center;
      font-size: 11px; font-weight: 700; color: var(--accent); font-family: var(--mono);
    }
    .guide-text { font-size: 12px; color: var(--text2); line-height: 1.7; }
    .guide-text strong { color: var(--text); }

    /* ‚îÄ‚îÄ‚îÄ INPUTS ‚îÄ‚îÄ‚îÄ */
    .input-row { display: flex; gap: 10px; margin-bottom: 14px; }
    .input-field {
      flex: 1;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      padding: 12px 16px;
      color: var(--text); font-size: 15px;
      outline: none; font-family: var(--mono);
      transition: border-color .2s, box-shadow .2s;
      letter-spacing: .3px;
    }
    .input-field:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim), 0 0 14px rgba(0,229,255,.08);
    }
    .input-field::placeholder { color: var(--text3); font-family: inherit; letter-spacing: 0; }

    /* ‚îÄ‚îÄ‚îÄ MODE / DEPTH TOGGLES ‚îÄ‚îÄ‚îÄ */
    .options-row { display: flex; gap: 16px; margin-bottom: 14px; flex-wrap: wrap; }
    .opt-group { display: flex; flex-direction: column; gap: 5px; }
    .opt-lbl { font-size: 10px; color: var(--text2); text-transform: uppercase; letter-spacing: .9px; font-family: var(--mono); }
    .toggle-row {
      display: flex;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs); overflow: hidden;
    }
    .tbtn {
      padding: 8px 18px; font-size: 12px; font-family: var(--mono);
      border: none; background: transparent; color: var(--text2);
      cursor: pointer; transition: all .2s; white-space: nowrap;
    }
    .tbtn.active {
      background: rgba(0,229,255,.1); color: var(--accent);
      font-weight: 700;
    }

    /* mode description strip */
    .mode-strip {
      font-size: 11.5px; color: var(--text2); margin-bottom: 14px;
      padding: 9px 13px;
      background: rgba(124,58,237,.06);
      border-left: 2px solid var(--accent2);
      border-radius: 0 var(--rs) var(--rs) 0;
      font-family: var(--mono); line-height: 1.6;
    }

    /* ‚îÄ‚îÄ‚îÄ BUTTONS ‚îÄ‚îÄ‚îÄ */
    .btn {
      padding: 11px 22px; border-radius: var(--rs);
      border: none; cursor: pointer;
      font-size: 12.5px; font-weight: 700; letter-spacing: .8px;
      font-family: var(--mono);
      transition: all .18s;
      display: inline-flex; align-items: center; gap: 7px;
    }
    .btn-primary {
      background: rgba(0,229,255,.09); color: var(--accent);
      border: 1px solid rgba(0,229,255,.35);
    }
    .btn-primary:hover {
      background: rgba(0,229,255,.16);
      box-shadow: var(--accent-glow); transform: translateY(-1px);
    }
    .btn-secondary {
      background: var(--surface2); color: var(--text2);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover { border-color: var(--accent2); color: var(--accent2); }
    .btn-danger {
      background: rgba(255,34,85,.08); color: var(--danger);
      border: 1px solid rgba(255,34,85,.3);
    }
    .btn-danger:hover { background: rgba(255,34,85,.16); box-shadow: 0 0 12px rgba(255,34,85,.25); }
    .btn:disabled { opacity: .3; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
    .btn-row { display: flex; gap: 8px; flex-wrap: wrap; }

    /* ‚îÄ‚îÄ‚îÄ PROGRESS ‚îÄ‚îÄ‚îÄ */
    .prog-wrap { height: 2px; background: var(--border); border-radius: 2px; margin: 12px 0; overflow: hidden; }
    .prog-bar {
      height: 100%; border-radius: 2px;
      background: linear-gradient(90deg, var(--accent2), var(--accent));
      transition: width .3s; width: 0;
      box-shadow: 0 0 8px rgba(0,229,255,.6);
    }
    .prog-bar.ind { animation: ind 1.5s ease-in-out infinite; width: 30%; }
    @keyframes ind { 0%{transform:translateX(-200%)} 100%{transform:translateX(500%)} }

    /* ‚îÄ‚îÄ‚îÄ TERMINAL FEED ‚îÄ‚îÄ‚îÄ */
    .feed {
      background: #01010a;
      border: 1px solid var(--border);
      border-radius: var(--rs);
      height: 260px; overflow-y: auto;
      padding: 10px 12px;
      font-family: var(--mono); font-size: 12px;
      scroll-behavior: smooth;
    }
    .feed-entry {
      padding: 2px 4px; border-radius: 3px; margin-bottom: 1px;
      display: flex; align-items: baseline; gap: 8px; line-height: 1.55;
    }
    .fe-ts      { color: var(--text3); font-size: 10px; min-width: 54px; flex-shrink: 0; }
    .fe-info    { color: var(--text2); }
    .fe-checking{ color: rgba(0,229,255,.55); }
    .fe-empty   { color: var(--text3); }
    .fe-used    { color: rgba(255,170,0,.65); }
    .fe-found   {
      background: var(--success-dim); color: var(--success); font-weight: 600;
      border: 1px solid rgba(0,255,136,.18); text-shadow: 0 0 6px rgba(0,255,136,.5);
    }
    .fe-error  { color: var(--danger); }
    .fe-jackpot {
      background: linear-gradient(90deg, rgba(0,229,255,.07), rgba(124,58,237,.07));
      color: var(--accent); font-weight: 700;
      border: 1px solid rgba(0,229,255,.25);
      animation: jackpot .9s ease-in-out infinite;
      text-shadow: 0 0 8px var(--accent);
    }
    @keyframes jackpot { 0%,100%{opacity:1} 50%{opacity:.55} }

    /* ‚îÄ‚îÄ‚îÄ RESULTS ‚îÄ‚îÄ‚îÄ */
    .result-item {
      background: var(--surface2);
      border: 1px solid rgba(0,255,136,.35);
      border-radius: var(--rs); padding: 18px; margin-bottom: 12px;
      box-shadow: 0 0 24px rgba(0,255,136,.05);
    }
    .result-bal {
      font-size: 26px; font-weight: 800; color: var(--success);
      margin-bottom: 12px; font-family: var(--mono);
      text-shadow: 0 0 12px rgba(0,255,136,.55);
    }
    .result-field { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 12px; }
    .rf-lbl { color: var(--text2); min-width: 72px; flex-shrink: 0; font-family: var(--mono); font-size: 10.5px; text-transform: uppercase; letter-spacing: .6px; }
    .rf-val { color: var(--text); font-family: var(--mono); font-size: 11.5px; word-break: break-all; flex: 1; }
    .copy-btn {
      padding: 3px 8px; font-size: 10px; font-family: var(--mono);
      background: var(--surface3); border: 1px solid var(--border);
      border-radius: 4px; color: var(--text2);
      cursor: pointer; transition: all .2s; white-space: nowrap; flex-shrink: 0;
    }
    .copy-btn:hover { border-color: var(--accent); color: var(--accent); }
    .expl-link { font-size: 11px; color: var(--accent); text-decoration: none; flex-shrink: 0; }
    .expl-link:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ‚îÄ BATCH TEXTAREA ‚îÄ‚îÄ‚îÄ */
    .textarea {
      width: 100%;
      background: var(--surface2); border: 1px solid var(--border);
      border-radius: var(--rs); padding: 11px 14px;
      color: var(--text); font-size: 13px; line-height: 1.7;
      outline: none; resize: vertical; min-height: 110px;
      font-family: var(--mono);
      transition: border-color .2s, box-shadow .2s;
    }
    .textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
    .textarea::placeholder { color: var(--text3); font-family: inherit; }

    /* ‚îÄ‚îÄ‚îÄ HUNT TAB ‚îÄ‚îÄ‚îÄ */
    .hunt-intro {
      color: var(--text2); font-size: 13px; margin-bottom: 16px;
      line-height: 1.8; font-family: var(--mono);
    }
    .odds-pill {
      display: inline-flex; align-items: center; gap: 8px;
      background: rgba(124,58,237,.08); border: 1px solid rgba(124,58,237,.25);
      border-radius: var(--rs); padding: 8px 16px;
      font-size: 12px; color: var(--accent2); font-family: var(--mono);
      margin-bottom: 18px;
    }

    /* ‚îÄ‚îÄ‚îÄ WARN / INFO BOXES ‚îÄ‚îÄ‚îÄ */
    .warn-box {
      background: rgba(255,170,0,.05); border: 1px solid rgba(255,170,0,.18);
      border-radius: var(--rs); padding: 10px 14px;
      font-size: 12px; color: rgba(255,170,0,.85); margin-bottom: 16px; line-height: 1.6;
    }
    .info-box {
      background: rgba(0,229,255,.04); border: 1px solid rgba(0,229,255,.14);
      border-radius: var(--rs); padding: 10px 14px;
      font-size: 12px; color: var(--text2); margin-bottom: 14px; line-height: 1.7;
    }
    .info-box strong { color: var(--accent); }
    .hint { font-size: 12.5px; color: var(--text2); margin-bottom: 14px; line-height: 1.7; }

    /* ‚îÄ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ‚îÄ */
    .toast {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(80px);
      background: var(--surface2); border: 1px solid var(--border);
      border-radius: var(--rs); padding: 10px 20px; font-size: 13px;
      font-family: var(--mono); z-index: 1000; opacity: 0;
      transition: all .25s; pointer-events: none;
      white-space: nowrap; max-width: 90vw;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

    /* ‚îÄ‚îÄ‚îÄ MEMORY GUIDE ‚îÄ‚îÄ‚îÄ */
    .step-dots { display: flex; gap: 8px; margin-bottom: 20px; }
    .step-dot {
      width: 28px; height: 4px; border-radius: 2px;
      background: var(--border); transition: all .25s;
    }
    .step-dot.active { background: var(--accent); box-shadow: 0 0 8px var(--accent); }
    .step-dot.done   { background: var(--success); }
    .mem-step-title {
      font-size: 11px; color: var(--text2); margin-bottom: 12px;
      text-transform: uppercase; letter-spacing: 1px; font-family: var(--mono);
    }
    .mem-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .mem-btn {
      padding: 9px 15px; border-radius: var(--rs);
      border: 1px solid var(--border); background: var(--surface2);
      color: var(--text2); cursor: pointer; font-size: 12px;
      transition: all .2s; font-family: var(--mono);
    }
    .mem-btn:hover  { border-color: rgba(0,229,255,.4); color: var(--text); }
    .mem-btn.active { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); font-weight: 700; }
    .mem-word-cloud {
      display: flex; flex-wrap: wrap; gap: 6px;
      max-height: 130px; overflow-y: auto;
      background: #01010a; border: 1px solid var(--border);
      border-radius: var(--rs); padding: 10px;
    }
    .mem-word-tag {
      padding: 3px 10px; background: var(--surface3);
      border: 1px solid var(--border); border-radius: 20px;
      font-size: 11px; color: var(--text2); font-family: var(--mono);
    }

    /* ‚îÄ‚îÄ‚îÄ FEELING LUCKY ‚îÄ‚îÄ‚îÄ */
    .lucky-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(125px, 1fr)); gap: 8px; margin: 12px 0; }
    .lucky-word {
      padding: 9px 10px; background: var(--surface2);
      border: 1px solid var(--border); border-radius: var(--rs);
      font-size: 12px; color: var(--text2); text-align: center;
      animation: fadeIn .25s ease; font-family: var(--mono);
    }
    .lucky-word.checking { border-color: var(--accent); color: var(--accent); box-shadow: inset 0 0 8px var(--accent-dim); }
    .lucky-word.empty    { opacity: .28; }
    .lucky-word.used     { border-color: var(--warning); color: var(--warning); }
    .lucky-word.found    { background: var(--success-dim); border-color: var(--success); color: var(--success); font-weight: 700; box-shadow: 0 0 14px rgba(0,255,136,.18); }
    @keyframes fadeIn { from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:none} }

    /* ‚îÄ‚îÄ‚îÄ AI SUGGEST ‚îÄ‚îÄ‚îÄ */
    .api-row { display: flex; gap: 8px; margin-bottom: 14px; align-items: flex-start; }
    .api-key-input { flex: 1; font-family: var(--mono); font-size: 13px; }
    .provider-badge {
      font-size: 10.5px; color: var(--text2); padding: 4px 10px;
      background: var(--surface2); border: 1px solid var(--border);
      border-radius: 6px; white-space: nowrap; flex-shrink: 0;
      margin-top: 11px; font-family: var(--mono);
    }
    .ai-word-cloud {
      display: flex; flex-wrap: wrap; gap: 6px;
      max-height: 150px; overflow-y: auto;
      background: #01010a; border: 1px solid var(--border);
      border-radius: var(--rs); padding: 10px;
    }
    .ai-word-tag {
      padding: 3px 10px;
      background: rgba(124,58,237,.07); border: 1px solid rgba(124,58,237,.22);
      border-radius: 20px; font-size: 11px; color: rgba(167,139,250,.9); font-family: var(--mono);
    }

    /* ‚îÄ‚îÄ‚îÄ SECTION LABEL ‚îÄ‚îÄ‚îÄ */
    .section-lbl {
      font-size: 10px; font-family: var(--mono); letter-spacing: 1.2px;
      text-transform: uppercase; color: var(--text3); margin-bottom: 8px;
    }

    /* ‚îÄ‚îÄ‚îÄ KEYSPACE BROWSER ‚îÄ‚îÄ‚îÄ */
    .ks-nav { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:14px; align-items:center; }
    .ks-page-input { width:120px !important; }
    .ks-table { width:100%; border-collapse:collapse; font-family:var(--mono); font-size:11px; }
    .ks-table th { padding:8px 6px; background:var(--surface2); border-bottom:1px solid var(--border); color:var(--text2); text-transform:uppercase; letter-spacing:.7px; font-size:9.5px; text-align:left; }
    .ks-table td { padding:7px 6px; border-bottom:1px solid var(--border); vertical-align:middle; }
    .ks-table tr:hover td { background:rgba(0,229,255,.03); }
    .ks-num { color:var(--text3); font-size:10px; min-width:30px; white-space:nowrap; }
    .ks-hex { color:var(--text2); cursor:pointer; white-space:nowrap; }
    .ks-hex:hover { color:var(--accent); }
    .ks-addr { color:var(--text); cursor:pointer; font-size:10.5px; white-space:nowrap; overflow:hidden; max-width:120px; text-overflow:ellipsis; }
    .ks-addr:hover { color:var(--accent); }
    .ks-info-bar { font-size:11.5px; color:var(--text2); font-family:var(--mono); background:rgba(124,58,237,.06); border-left:2px solid var(--accent2); padding:8px 12px; border-radius:0 var(--rs) var(--rs) 0; margin-bottom:14px; }

    /* ‚îÄ‚îÄ‚îÄ HALL OF SHAME ‚îÄ‚îÄ‚îÄ */
    .shame-table { width:100%; border-collapse:collapse; font-size:11.5px; }
    .shame-table th { padding:7px 10px; background:var(--surface2); border-bottom:1px solid var(--border); color:var(--text2); text-transform:uppercase; letter-spacing:.7px; font-size:9.5px; text-align:left; font-family:var(--mono); }
    .shame-table td { padding:9px 10px; border-bottom:1px solid var(--border); }
    .shame-table tr:last-child td { border-bottom:none; }
    .shame-rank { color:var(--text3); font-family:var(--mono); font-size:11px; text-align:center; width:30px; }
    .shame-pass { color:var(--text); font-family:var(--mono); font-weight:600; }
    .shame-badge { display:inline-block; padding:2px 7px; border-radius:4px; background:rgba(255,34,85,.1); border:1px solid rgba(255,34,85,.25); color:var(--danger); font-size:10px; font-family:var(--mono); white-space:nowrap; }
    .shame-yr { color:var(--text2); font-size:10.5px; font-family:var(--mono); }

    /* ‚îÄ‚îÄ‚îÄ PROBABILITY CALCULATOR ‚îÄ‚îÄ‚îÄ */
    .prob-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:10px; margin:12px 0; }
    .prob-card { background:var(--surface2); border:1px solid var(--border); border-radius:var(--rs); padding:14px 12px; text-align:center; }
    .prob-icon { font-size:22px; margin-bottom:6px; }
    .prob-lbl { font-size:10.5px; color:var(--text2); font-family:var(--mono); margin-bottom:6px; }
    .prob-val { font-size:12px; font-weight:700; color:var(--accent); font-family:var(--mono); }
    .prob-val.dim { color:var(--text3); }

    /* ‚îÄ‚îÄ‚îÄ DICTIONARY PRESETS ‚îÄ‚îÄ‚îÄ */
    .dict-presets { display:flex; gap:7px; flex-wrap:wrap; margin-bottom:12px; }
    .dict-preset-btn { padding:7px 13px; font-size:11px; border-radius:var(--rs); border:1px solid var(--border); background:var(--surface2); color:var(--text2); cursor:pointer; font-family:var(--mono); transition:all .2s; }
    .dict-preset-btn:hover { border-color:var(--accent2); color:var(--accent2); }

    /* ‚îÄ‚îÄ‚îÄ RESPONSIVE ‚îÄ‚îÄ‚îÄ */
    @media (max-width: 580px) {
      .stats-bar { grid-template-columns: repeat(2, 1fr); }
      .header { padding: 11px 13px; }
      .header-title { font-size: 14px; letter-spacing: 2px; }
      .container { padding: 12px 10px; }
      .card { padding: 15px; }
      .btn { padding: 10px 15px; font-size: 12px; }
      .input-field { font-size: 14px; }
      .stat-val { font-size: 19px; }
    }
  </style>
</head>
<body>

<!-- ‚îÄ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ -->
<header class="header">
  <div class="header-brand">
    <span class="header-logo">‚Çø</span>
    <div>
      <div class="header-title">QBTC SCANNER</div>
      <div class="header-sub">Brain wallet &amp; BIP39 recovery ‚Äî runs in your browser</div>
    </div>
  </div>
  <div class="header-right">
    <span class="badge badge-idle" id="statusBadge">‚è∏ Idle</span>
  </div>
</header>

<!-- ‚îÄ‚îÄ‚îÄ STATS BAR ‚îÄ‚îÄ‚îÄ -->
<div class="stats-bar">
  <div class="stat">
    <div class="stat-val" id="sWords">0</div>
    <div class="stat-lbl">Checked</div>
  </div>
  <div class="stat">
    <div class="stat-val" id="sVars">0</div>
    <div class="stat-lbl">Variations</div>
  </div>
  <div class="stat">
    <div class="stat-val" id="sAddrs">0</div>
    <div class="stat-lbl">Addresses</div>
  </div>
  <div class="stat">
    <div class="stat-val" id="sFound">0</div>
    <div class="stat-lbl">Found</div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ TABS ‚îÄ‚îÄ‚îÄ -->
<nav class="tabs" id="tabBar">
  <button class="tab active" onclick="switchTab('single')">üîç Single</button>
  <button class="tab" onclick="switchTab('batch')">üìã Batch</button>
  <button class="tab" onclick="switchTab('hunt')">üé≤ Hunt</button>
  <button class="tab" onclick="switchTab('memory')">üß† Memory</button>
  <button class="tab" onclick="switchTab('ai')">ü§ñ AI</button>
  <button class="tab" onclick="switchTab('keys')">üîë Keys</button>
</nav>

<div class="container">

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SINGLE CHECK PANEL
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel" id="panelSingle">

    <!-- Quick guide for new users -->
    <details class="guide">
      <summary>Quick Guide ‚Äî how to use this tool</summary>
      <div class="guide-body">
        <div class="guide-step">
          <div class="guide-num">1</div>
          <div class="guide-text"><strong>Enter a word or phrase</strong> you think you used as a password when creating a Bitcoin wallet (e.g. "dragon", "my secret", "satoshi2011")</div>
        </div>
        <div class="guide-step">
          <div class="guide-num">2</div>
          <div class="guide-text"><strong>Choose Brain Wallet</strong> for a single word/phrase, or <strong>BIP39 Seed</strong> if you had a 12/24-word recovery phrase. Start with Brain Wallet ‚Äî it's faster.</div>
        </div>
        <div class="guide-step">
          <div class="guide-num">3</div>
          <div class="guide-text"><strong>Click Check Word</strong> ‚Äî the scanner will test the word and dozens of variations (with numbers, capitals, symbols) against the Bitcoin blockchain.</div>
        </div>
        <div class="guide-step">
          <div class="guide-num">4</div>
          <div class="guide-text">If a wallet is found with balance, it appears in the <strong>Found Wallets</strong> section below with the private key. Save it immediately.</div>
        </div>
      </div>
    </details>

    <div class="card">
      <div class="card-title">// CHECK A WORD OR PHRASE</div>

      <div class="warn-box">
        ‚ö†Ô∏è All computation happens locally in your browser ‚Äî nothing is sent to any server except public blockchain APIs to check balances.
      </div>

      <div class="section-lbl">Your passphrase</div>
      <div class="input-row">
        <input id="wordInput" type="text" class="input-field"
          placeholder="Type a word, phrase, or passphrase‚Ä¶"
          autocomplete="off" autocorrect="off" spellcheck="false">
      </div>

      <div class="options-row">
        <div class="opt-group">
          <div class="opt-lbl">Derivation Mode</div>
          <div class="toggle-row">
            <button class="tbtn active" id="modeBW"  onclick="setMode('brainwallet')">Brain Wallet</button>
            <button class="tbtn"        id="modeBIP" onclick="setMode('bip39')">BIP39 Seed</button>
          </div>
        </div>
        <div class="opt-group">
          <div class="opt-lbl">Search Depth</div>
          <div class="toggle-row">
            <button class="tbtn active" id="depthN" onclick="setDepth('normal')">Normal (~30 vars)</button>
            <button class="tbtn"        id="depthD" onclick="setDepth('deep')">Deep (~80 vars)</button>
          </div>
        </div>
      </div>

      <div class="mode-strip" id="modeHint">
        Brain Wallet: SHA256(passphrase) ‚Üí private key ¬∑ checks Legacy, P2SH-SegWit &amp; Native SegWit addresses
      </div>

      <div class="btn-row">
        <button class="btn btn-primary" id="btnCheck" onclick="startCheck()">‚ñ∂ CHECK WORD</button>
        <button class="btn btn-danger hidden" id="btnStop" onclick="stopCheck()">‚ñ† STOP</button>
      </div>

      <div class="prog-wrap hidden" id="progWrap">
        <div class="prog-bar" id="progBar"></div>
      </div>
    </div>

    <!-- Live feed -->
    <div class="card hidden" id="feedCard">
      <div class="card-title" style="justify-content:space-between">
        <span>// LIVE OUTPUT</span>
        <button onclick="clearFeed()" style="background:none;border:none;color:var(--text3);cursor:pointer;font-size:11px;font-family:var(--mono)">[ CLEAR ]</button>
      </div>
      <div class="feed" id="feed"></div>
    </div>

    <!-- Results (shared across tabs) -->
    <div class="card hidden" id="resultsCard">
      <div class="card-title">
        // FOUND WALLETS
        <span class="badge badge-run" id="foundBadge">0</span>
      </div>
      <div id="resultsList"></div>
    </div>

  </div><!-- /panelSingle -->


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       BATCH CHECK PANEL
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel hidden" id="panelBatch">

    <div class="card">
      <div class="card-title">// BATCH CHECK</div>
      <div class="info-box">
        Paste a list of words or phrases ‚Äî <strong>one per line</strong>. Each will be checked with all variations automatically.
        Ideal for word lists generated by Memory Guide or AI Suggest.
      </div>

      <div class="section-lbl">Quick presets ‚Äî load a word list instantly</div>
      <div class="dict-presets">
        <button class="dict-preset-btn" onclick="loadDictPreset('common')">üìã Top Common</button>
        <button class="dict-preset-btn" onclick="loadDictPreset('crypto')">‚Çø Crypto Phrases</button>
        <button class="dict-preset-btn" onclick="loadDictPreset('pop')">üé¨ Pop Culture</button>
        <button class="dict-preset-btn" onclick="loadDictPreset('shame')">üíÄ Hall of Shame</button>
      </div>

      <div class="section-lbl">Words to check (one per line)</div>
      <div style="margin-bottom:14px">
        <textarea id="batchInput" class="textarea"
          placeholder="satoshi&#10;nakamoto&#10;bitcoin&#10;password123&#10;dragon2013&#10;‚Ä¶"></textarea>
      </div>

      <div class="options-row">
        <div class="opt-group">
          <div class="opt-lbl">Derivation Mode</div>
          <div class="toggle-row">
            <button class="tbtn active" id="batchModeBW"  onclick="setBatchMode('brainwallet')">Brain Wallet</button>
            <button class="tbtn"        id="batchModeBIP" onclick="setBatchMode('bip39')">BIP39 Seed</button>
          </div>
        </div>
        <div class="opt-group">
          <div class="opt-lbl">Search Depth</div>
          <div class="toggle-row">
            <button class="tbtn active" id="batchDepthN" onclick="setBatchDepth('normal')">Normal</button>
            <button class="tbtn"        id="batchDepthD" onclick="setBatchDepth('deep')">Deep</button>
          </div>
        </div>
      </div>

      <div class="btn-row">
        <button class="btn btn-primary" id="btnBatchCheck" onclick="startBatch()">‚ñ∂ CHECK ALL WORDS</button>
        <button class="btn btn-danger hidden" id="btnBatchStop" onclick="stopBatch()">‚ñ† STOP</button>
      </div>

      <div class="prog-wrap hidden" id="batchProgWrap">
        <div class="prog-bar" id="batchProgBar"></div>
      </div>
    </div>

    <div class="card hidden" id="batchFeedCard">
      <div class="card-title" style="justify-content:space-between">
        <span>// BATCH OUTPUT</span>
        <span id="batchProgress" style="font-size:11px;color:var(--text2);font-family:var(--mono)"></span>
      </div>
      <div class="feed" id="batchFeed"></div>
    </div>

  </div><!-- /panelBatch -->


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       RANDOM KEY HUNT PANEL
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel hidden" id="panelHunt">

    <div class="card">
      <div class="card-title">// RANDOM KEY HUNT</div>

      <div class="hunt-intro">
        Generate random Bitcoin private keys and check their balances. Pure probability ‚Äî
        someone out there has to be the one to find it. Uses your browser's cryptographically
        secure random number generator (<code style="color:var(--accent)">crypto.getRandomValues</code>).
      </div>

      <div class="odds-pill">
        ‚ö° Probability per key: ~1 in 10<sup>77</sup> ‚Äî for entertainment only
      </div>

      <div class="btn-row" style="margin-bottom:14px">
        <button class="btn btn-secondary" id="bH10"   onclick="startHunt(10)">Hunt √ó 10</button>
        <button class="btn btn-secondary" id="bH100"  onclick="startHunt(100)">Hunt √ó 100</button>
        <button class="btn btn-secondary" id="bH1000" onclick="startHunt(1000)">Hunt √ó 1000</button>
        <button class="btn btn-danger hidden" id="bHStop" onclick="stopHunt()">‚ñ† STOP</button>
      </div>

      <div class="feed" id="huntFeed" style="height:240px"></div>
    </div>

    <!-- Probability Context Card -->
    <div class="card">
      <div class="card-title">// PROBABILITY CONTEXT</div>
      <p class="hint" style="margin-bottom:14px">How likely is finding a funded wallet compared to other rare events?</p>
      <div class="prob-grid">
        <div class="prob-card">
          <div class="prob-icon">üé∞</div>
          <div class="prob-lbl">Powerball Jackpot</div>
          <div class="prob-val">1 in 292M</div>
        </div>
        <div class="prob-card">
          <div class="prob-icon">‚ö°</div>
          <div class="prob-lbl">Lightning Strike</div>
          <div class="prob-val">1 in 15,300</div>
        </div>
        <div class="prob-card">
          <div class="prob-icon">üß¨</div>
          <div class="prob-lbl">DNA Match (stranger)</div>
          <div class="prob-val">1 in 10B</div>
        </div>
        <div class="prob-card">
          <div class="prob-icon">‚Çø</div>
          <div class="prob-lbl">Find Funded Wallet</div>
          <div class="prob-val dim">1 in 10<sup>67</sup></div>
        </div>
      </div>
      <div class="info-box" style="margin-bottom:0">
        At 1 billion keys/sec (fastest GPU rig), exhausting the entire BTC keyspace would take <strong>~10<sup>59</sup> years</strong>. The age of the universe is ~1.4√ó10<sup>10</sup> years.
        <br>Brain wallets (words) are a different story ‚Äî weak passphrases can be checked exhaustively.
      </div>
    </div>

  </div><!-- /panelHunt -->


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       MEMORY GUIDE PANEL
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel hidden" id="panelMemory">

    <div class="card">
      <div class="card-title">// MEMORY GUIDE</div>
      <p class="hint">Answer a few questions to build a personalized word list based on your memories. No typing required for most steps.</p>

      <!-- Wizard progress bars -->
      <div class="step-dots">
        <div class="step-dot active"></div>
        <div class="step-dot"></div>
        <div class="step-dot"></div>
        <div class="step-dot"></div>
      </div>

      <!-- Step 0: Year -->
      <div id="memStep0">
        <div class="mem-step-title">Step 1 of 4 ‚Äî When did you create this wallet?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="year" data-val="2009" onclick="memAnswer('year','2009')">2009</button>
          <button class="mem-btn" data-mem="year" data-val="2010" onclick="memAnswer('year','2010')">2010</button>
          <button class="mem-btn" data-mem="year" data-val="2011" onclick="memAnswer('year','2011')">2011</button>
          <button class="mem-btn" data-mem="year" data-val="2012" onclick="memAnswer('year','2012')">2012</button>
          <button class="mem-btn" data-mem="year" data-val="2013" onclick="memAnswer('year','2013')">2013</button>
          <button class="mem-btn" data-mem="year" data-val="2014" onclick="memAnswer('year','2014')">2014</button>
          <button class="mem-btn" data-mem="year" data-val="2015" onclick="memAnswer('year','2015')">2015</button>
          <button class="mem-btn" data-mem="year" data-val="2016" onclick="memAnswer('year','2016')">2016</button>
          <button class="mem-btn" data-mem="year" data-val="2017" onclick="memAnswer('year','2017')">2017</button>
          <button class="mem-btn" data-mem="year" data-val="2018" onclick="memAnswer('year','2018')">2018</button>
          <button class="mem-btn" data-mem="year" data-val="2019" onclick="memAnswer('year','2019')">2019</button>
          <button class="mem-btn" data-mem="year" data-val="2020" onclick="memAnswer('year','2020')">2020</button>
          <button class="mem-btn" data-mem="year" data-val="2021" onclick="memAnswer('year','2021')">2021</button>
          <button class="mem-btn" data-mem="year" data-val="not_sure" onclick="memAnswer('year','not_sure')">Not sure</button>
        </div>
      </div>

      <!-- Step 1: Topic -->
      <div id="memStep1" class="hidden">
        <div class="mem-step-title">Step 2 of 4 ‚Äî What were your main interests at the time?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="topic" data-val="gaming"   onclick="memAnswer('topic','gaming')">üéÆ Gaming</button>
          <button class="mem-btn" data-mem="topic" data-val="movies"   onclick="memAnswer('topic','movies')">üé¨ Movies</button>
          <button class="mem-btn" data-mem="topic" data-val="sports"   onclick="memAnswer('topic','sports')">‚öΩ Sports</button>
          <button class="mem-btn" data-mem="topic" data-val="music"    onclick="memAnswer('topic','music')">üéµ Music</button>
          <button class="mem-btn" data-mem="topic" data-val="crypto"   onclick="memAnswer('topic','crypto')">‚Çø Crypto</button>
          <button class="mem-btn" data-mem="topic" data-val="nature"   onclick="memAnswer('topic','nature')">üêâ Nature / Fantasy</button>
          <button class="mem-btn" data-mem="topic" data-val="personal" onclick="memAnswer('topic','personal')">‚ù§Ô∏è Personal</button>
          <button class="mem-btn" data-mem="topic" data-val="work"     onclick="memAnswer('topic','work')">üíº Work / Tech</button>
        </div>
      </div>

      <!-- Step 2: Platform -->
      <div id="memStep2" class="hidden">
        <div class="mem-step-title">Step 3 of 4 ‚Äî What device or platform were you using?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="platform" data-val="windows" onclick="memAnswer('platform','windows')">üñ• Windows PC</button>
          <button class="mem-btn" data-mem="platform" data-val="mac"     onclick="memAnswer('platform','mac')">üçé Mac</button>
          <button class="mem-btn" data-mem="platform" data-val="mobile"  onclick="memAnswer('platform','mobile')">üì± Mobile</button>
          <button class="mem-btn" data-mem="platform" data-val="linux"   onclick="memAnswer('platform','linux')">üêß Linux</button>
          <button class="mem-btn" data-mem="platform" data-val="web"     onclick="memAnswer('platform','web')">üåê Web / Online tool</button>
          <button class="mem-btn" data-mem="platform" data-val="any"     onclick="memAnswer('platform','any')">ü§∑ Not sure</button>
        </div>
      </div>

      <!-- Step 3: Hints -->
      <div id="memStep3" class="hidden">
        <div class="mem-step-title">Step 4 of 4 ‚Äî Any hint words you remember? (optional)</div>
        <div class="info-box" style="margin-bottom:12px">
          Type any words you associate with the passphrase ‚Äî your pet's name, a favourite character, a place. Separate with spaces.
        </div>
        <div class="input-row" style="margin-bottom:12px">
          <input id="memHintInput" type="text" class="input-field"
            placeholder="e.g.  dragon  fire  lucky  2013"
            oninput="memAnswers.hint = this.value">
        </div>
        <div class="btn-row">
          <button class="btn btn-primary" onclick="updateMemWordCloud()">‚ñ∂ GENERATE WORD LIST</button>
          <button class="btn btn-secondary" onclick="resetMemWizard()">‚Ü∫ Start Over</button>
        </div>
      </div>
    </div>

    <!-- Generated word list -->
    <div class="card hidden" id="memResultsSection">
      <div class="card-title" style="justify-content:space-between">
        <span>// GENERATED WORDS</span>
        <span id="memWordCount" style="font-size:11px;color:var(--text2);font-family:var(--mono)">0 words</span>
      </div>
      <div class="mem-word-cloud" id="memWordCloud"></div>
      <div class="btn-row" style="margin-top:14px">
        <button class="btn btn-primary" onclick="sendMemToBatch()">üìã Send to Batch Check</button>
        <button class="btn btn-secondary" onclick="feelingLucky()">üçÄ Try My Luck</button>
      </div>
    </div>

    <!-- Feeling Lucky -->
    <div class="card" id="luckySection">
      <div class="card-title">// FEELING LUCKY</div>
      <p class="hint">
        Instantly check the most common brain wallet passphrases with one click ‚Äî no setup needed.
        If you generated a word list above, those words are included automatically.
      </p>
      <div class="btn-row" style="margin-bottom:12px">
        <button class="btn btn-primary" id="btnLucky" onclick="feelingLucky()">üçÄ TRY MY LUCK</button>
      </div>
      <div class="lucky-grid" id="luckyGrid"></div>
    </div>

  </div><!-- /panelMemory -->


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       AI SUGGEST PANEL
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel hidden" id="panelAi">

    <div class="card">
      <div class="card-title">// AI WORD SUGGEST</div>
      <p class="hint">Describe your context and let AI generate personalised passphrase candidates. Works best when you provide details about your interests, year, and platform.</p>

      <div class="warn-box">
        üîë Your API key goes directly from your browser to the AI provider ‚Äî never through our servers.
        <strong>Groq is completely free</strong> ‚Äî get a key at
        <a href="https://console.groq.com" target="_blank" rel="noopener" style="color:var(--accent)">console.groq.com</a>
      </div>

      <div class="section-lbl">API Key</div>
      <div class="api-row">
        <input id="aiApiKey" type="password" class="input-field api-key-input"
          placeholder="Groq key  gsk_‚Ä¶   or   OpenAI key  sk-‚Ä¶"
          oninput="detectAIProvider(this.value)">
        <span class="provider-badge" id="aiProviderBadge">Auto-detect</span>
      </div>

      <div style="margin-bottom:14px">
        <div class="section-lbl">Your context &amp; hints</div>
        <textarea id="aiContext" class="textarea" style="min-height:90px"
          placeholder="e.g.  I was into gaming in 2013, used Windows, favourite game was Minecraft, dog's name was Max, grew up in London‚Ä¶"></textarea>
      </div>

      <div class="btn-row">
        <button class="btn btn-primary" id="btnAIGenerate" onclick="generateAIWords()">ü§ñ GENERATE WORDS</button>
      </div>
    </div>

    <!-- AI Results -->
    <div class="card hidden" id="aiResultsSection">
      <div class="card-title" style="justify-content:space-between">
        <span>// AI SUGGESTIONS</span>
        <span id="aiWordCount" style="font-size:11px;color:var(--text2);font-family:var(--mono)">0 words</span>
      </div>
      <div class="ai-word-cloud" id="aiWordCloud"></div>
      <div class="btn-row" style="margin-top:14px">
        <button class="btn btn-primary" onclick="sendAIToBatch()">üìã Send to Batch Check</button>
        <button class="btn btn-secondary" onclick="feelingLucky()">üçÄ Feeling Lucky</button>
      </div>
    </div>

  </div><!-- /panelAi -->


  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       KEYS TAB ‚Äî Inspector, Entropy, Keyspace, Graveyard
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="tab-panel hidden" id="panelKeys">

    <!-- Key Inspector -->
    <div class="card">
      <div class="card-title">// KEY INSPECTOR</div>
      <p class="hint">Paste any Bitcoin private key ‚Äî 64-char hex or WIF format (starts with 5, K or L). Instantly see every address type it produces.</p>

      <div class="section-lbl">Private key</div>
      <div class="input-row">
        <input id="kiInput" type="text" class="input-field"
          placeholder="hex: 1e99423a4ed27608...  or  WIF: 5HueCGU8rMjxECyD..."
          autocomplete="off" autocorrect="off" spellcheck="false">
      </div>
      <div class="btn-row">
        <button class="btn btn-primary" onclick="inspectKey()">üîç INSPECT KEY</button>
      </div>

      <div class="hidden" id="kiResult" style="margin-top:16px">
        <div class="result-item" style="border-color:var(--border);box-shadow:none" id="kiResultInner"></div>
      </div>
    </div>

    <!-- Entropy Key Generator -->
    <div class="card">
      <div class="card-title">// ENTROPY KEY GENERATOR</div>
      <p class="hint">Generate a cryptographically secure random Bitcoin private key using your browser's <code style="color:var(--accent)">crypto.getRandomValues</code>. Full 256-bit entropy ‚Äî nothing like a brain wallet.</p>

      <div class="warn-box" style="margin-bottom:14px">
        ‚ö†Ô∏è This generates a key that has never existed anywhere before. There is no recovery mechanism ‚Äî if you lose the key, the funds are gone forever.
      </div>

      <div class="btn-row" style="margin-bottom:14px">
        <button class="btn btn-primary" onclick="generateEntropyKey()">‚öÑ GENERATE RANDOM KEY</button>
      </div>

      <div class="hidden" id="entropyResult">
        <div class="result-item" style="border-color:var(--border);box-shadow:none" id="entropyResultInner"></div>
      </div>
    </div>

    <!-- Keyspace Browser -->
    <div class="card">
      <div class="card-title">// KEYSPACE BROWSER</div>
      <p class="hint">Browse Bitcoin private keys sequentially by page number. Each page shows 20 deterministic keys. <strong>For educational purposes only</strong> ‚Äî the odds of finding a funded key by sequential browsing are astronomically small.</p>

      <div class="info-box">
        Total keyspace: ~<strong style="color:var(--accent)">10<sup>77</sup></strong> possible keys.
        BTC uses a 256-bit private key space ‚Äî you can navigate any page. Click any address or key to copy it.
      </div>

      <div class="ks-nav">
        <input id="ksPageInput" type="text" class="input-field ks-page-input" placeholder="Page #" value="1" autocomplete="off">
        <button class="btn btn-primary" onclick="ksGoPage(document.getElementById('ksPageInput').value)">‚ñ∂ GO</button>
        <button class="btn btn-secondary" onclick="ksGoPage('1')">|‚Üê First</button>
        <button class="btn btn-secondary" onclick="ksPrev()">‚Üê Prev</button>
        <button class="btn btn-secondary" onclick="ksNext()">Next ‚Üí</button>
        <button class="btn btn-secondary" onclick="ksRandom()">‚öÑ Random</button>
      </div>

      <div style="overflow-x:auto">
        <table class="ks-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Private Key (hex, truncated)</th>
              <th>Legacy (1‚Ä¶)</th>
              <th>Native SegWit (bc1‚Ä¶)</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="ksTableBody">
            <tr><td colspan="5" style="text-align:center;color:var(--text3);padding:20px;font-family:var(--mono);font-size:12px">Loading keyspace‚Ä¶</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- The Graveyard -->
    <div class="card">
      <div class="card-title">// THE GRAVEYARD ‚Äî Cracked Brain Wallets</div>
      <p class="hint">These passphrases were found in wordlist attacks and their wallets drained ‚Äî some within milliseconds of creation. All addresses are now empty. This table demonstrates <strong>why simple words make terrible passphrases</strong>.</p>

      <div style="overflow-x:auto">
        <table class="shame-table">
          <thead>
            <tr>
              <th>Passphrase</th>
              <th>Cracked in</th>
              <th>~Year</th>
              <th>Address (1‚Ä¶)</th>
              <th>Why it failed</th>
            </tr>
          </thead>
          <tbody id="graveyardBody"></tbody>
        </table>
      </div>

      <div class="btn-row" style="margin-top:14px">
        <button class="btn btn-secondary" onclick="loadDictPreset('shame')">üìã Use Variations in Batch</button>
      </div>
    </div>

  </div><!-- /panelKeys -->


</div><!-- /container -->

<div class="toast" id="toast"></div>

<script type="module">
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  IMPORTS ‚Äî noble crypto libraries via esm.sh CDN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
import { sha256   } from 'https://esm.sh/@noble/hashes@1.7.2/sha256';
import { ripemd160} from 'https://esm.sh/@noble/hashes@1.7.2/ripemd160';
import { hmac     } from 'https://esm.sh/@noble/hashes@1.7.2/hmac';
import { sha512   } from 'https://esm.sh/@noble/hashes@1.7.2/sha512';
import { secp256k1} from 'https://esm.sh/@noble/curves@1.8.1/secp256k1';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TELEGRAM WEBAPP INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const tg = window.Telegram?.WebApp;
if (tg) {
  tg.ready();
  tg.expand(); // full-screen in Telegram
  // Apply Telegram theme to root element
  if (tg.colorScheme === 'light') {
    // light mode: keep our dark theme but signal awareness
    document.documentElement.style.setProperty('--bg', '#ffffff');
    document.documentElement.style.setProperty('--surface', '#f0f0f5');
    document.documentElement.style.setProperty('--surface2', '#e8e8ef');
    document.documentElement.style.setProperty('--text', '#000000');
    document.documentElement.style.setProperty('--text2', '#555555');
    document.documentElement.style.setProperty('--border', '#d0d0d8');
    document.documentElement.style.setProperty('--text3', '#999999');
    document.documentElement.style.setProperty('--surface3', '#dcdce4');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let mode  = 'brainwallet';
let depth = 'normal';
let batchMode  = 'brainwallet';
let batchDepth = 'normal';
let isChecking = false;
let isHunting  = false;
let isBatching = false;
let stopCheck  = false;
let stopHunt   = false;
let stopBatchFlag = false;

const stats = { words: 0, vars: 0, addrs: 0, found: 0, keys: 0 };

// Expose UI handlers to inline onclick attributes
window.setMode          = setMode;
window.setDepth         = setDepth;
window.setBatchMode     = setBatchMode;
window.setBatchDepth    = setBatchDepth;
window.startCheck       = startCheck;
window.stopCheck        = () => { stopCheck = true; byId('btnStop').textContent = '‚è≥ Stopping‚Ä¶'; };
window.startHunt        = startHunt;
window.stopHunt         = () => { stopHunt = true; byId('bHStop').textContent = '‚è≥ Stopping‚Ä¶'; };
window.startBatch       = startBatch;
window.stopBatch        = () => { stopBatchFlag = true; byId('btnBatchStop').textContent = '‚è≥ Stopping‚Ä¶'; };
window.clearFeed        = () => { byId('feed').innerHTML = ''; };
window.switchTab        = switchTab;
window.memAnswer        = memAnswer;
window.showMemStep      = showMemStep;
window.updateMemWordCloud = updateMemWordCloud;
window.sendMemToBatch   = sendMemToBatch;
window.resetMemWizard   = resetMemWizard;
window.feelingLucky     = feelingLucky;
window.generateAIWords  = generateAIWords;
window.sendAIToBatch    = sendAIToBatch;
window.detectAIProvider = detectAIProvider;
window.ksGoPage         = ksGoPage;
window.ksPrev           = ksPrev;
window.ksNext           = ksNext;
window.ksRandom         = ksRandom;
window.loadDictPreset   = loadDictPreset;
window.inspectKey       = inspectKey;
window.generateEntropyKey = generateEntropyKey;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TAB SWITCHING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function switchTab(name) {
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  byId('panel' + name.charAt(0).toUpperCase() + name.slice(1)).classList.remove('hidden');
  const tabs = { single: 0, batch: 1, hunt: 2, memory: 3, ai: 4, keys: 5 };
  document.querySelectorAll('.tab')[tabs[name]]?.classList.add('active');
  // Lazy-init keyspace on first visit
  if (name === 'keys' && !ksInitialized) { ksInitialized = true; renderKeyspacePage(1n); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UTILS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const byId = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));

function bytesToHex(b) {
  return Array.from(b, x => x.toString(16).padStart(2, '0')).join('');
}
function hexToBytes(hex) {
  if (hex.length & 1) hex = '0' + hex;
  const b = new Uint8Array(hex.length >> 1);
  for (let i = 0; i < hex.length; i += 2) b[i >> 1] = parseInt(hex.slice(i, i + 2), 16);
  return b;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BITCOIN PRIMITIVES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

function base58Encode(bytes) {
  if (!bytes.length) return '';
  let n = BigInt('0x' + bytesToHex(bytes));
  let s = '';
  while (n > 0n) { const r = Number(n % 58n); s = B58[r] + s; n /= 58n; }
  for (const b of bytes) { if (b !== 0) break; s = '1' + s; }
  return s;
}

function base58Check(version, payload) {
  const full = new Uint8Array([version, ...payload]);
  const chk  = sha256(sha256(full)).slice(0, 4);
  return base58Encode(new Uint8Array([...full, ...chk]));
}

function hash160(pub) {
  return ripemd160(sha256(pub));
}

// P2PKH  ‚Üí 1...
function pubToLegacy(pub) {
  return base58Check(0x00, hash160(pub));
}

// P2SH-P2WPKH ‚Üí 3...
function pubToP2SH(pub) {
  const h   = hash160(pub);
  const rs  = new Uint8Array([0x00, 0x14, ...h]); // OP_0 PUSH20 <hash>
  return base58Check(0x05, hash160(rs));
}

// Bech32 (native segwit P2WPKH) ‚Üí bc1q...
const B32C = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const B32G = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

function b32Polymod(v) {
  let c = 1;
  for (const x of v) {
    const t = c >> 25;
    c = ((c & 0x1ffffff) << 5) ^ x;
    for (let i = 0; i < 5; i++) if ((t >> i) & 1) c ^= B32G[i];
  }
  return c;
}
function b32Hrp(hrp) {
  const r = [];
  for (let i = 0; i < hrp.length; i++) r.push(hrp.charCodeAt(i) >> 5);
  r.push(0);
  for (let i = 0; i < hrp.length; i++) r.push(hrp.charCodeAt(i) & 31);
  return r;
}
function b32Checksum(hrp, data) {
  const poly = b32Polymod([...b32Hrp(hrp), ...data, 0, 0, 0, 0, 0, 0]) ^ 1;
  return Array.from({ length: 6 }, (_, i) => (poly >> (5 * (5 - i))) & 31);
}
function convertBits(data, from, to, pad = true) {
  let acc = 0, bits = 0;
  const out = [], maxv = (1 << to) - 1;
  for (const v of data) {
    acc = (acc << from) | v; bits += from;
    while (bits >= to) { bits -= to; out.push((acc >> bits) & maxv); }
  }
  if (pad && bits > 0) out.push((acc << (to - bits)) & maxv);
  return out;
}
function pubToNative(pub) {
  const h    = hash160(pub);
  const data = [0, ...convertBits(Array.from(h), 8, 5)];
  return 'bc1' + [...data, ...b32Checksum('bc', data)].map(d => B32C[d]).join('');
}

function toWIF(privBytes, compressed = true) {
  const d   = new Uint8Array([0x80, ...privBytes, ...(compressed ? [0x01] : [])]);
  const chk = sha256(sha256(d)).slice(0, 4);
  return base58Encode(new Uint8Array([...d, ...chk]));
}

// Base58 decode (reverse of base58Encode)
function base58Decode(str) {
  let n = 0n;
  for (const c of str) {
    const idx = B58.indexOf(c);
    if (idx < 0) throw new Error('Invalid Base58 character: ' + c);
    n = n * 58n + BigInt(idx);
  }
  const bytes = [];
  while (n > 0n) { bytes.unshift(Number(n & 0xffn)); n >>= 8n; }
  for (const c of str) { if (c !== '1') break; bytes.unshift(0); }
  return new Uint8Array(bytes);
}

// Parse hex (64 chars) or WIF ‚Üí hex private key string
function parsePrivKey(input) {
  const t = input.trim();
  if (/^[0-9a-fA-F]{64}$/.test(t)) return t.toLowerCase();
  // WIF decode
  const decoded = base58Decode(t);
  if (decoded.length < 5) throw new Error('Too short to be a valid key');
  const payload  = decoded.slice(0, -4);
  const checksum = decoded.slice(-4);
  const check    = sha256(sha256(payload)).slice(0, 4);
  for (let i = 0; i < 4; i++) if (checksum[i] !== check[i]) throw new Error('Invalid WIF checksum');
  if (payload[0] !== 0x80) throw new Error('Not a Bitcoin mainnet key (wrong version byte)');
  return bytesToHex(payload.slice(1, 33));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BRAIN WALLET  ‚Äî SHA256(passphrase) ‚Üí addresses
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function deriveBrainWallet(passphrase) {
  const priv = sha256(new TextEncoder().encode(passphrase));
  const pubC = secp256k1.getPublicKey(priv, true);
  const pubU = secp256k1.getPublicKey(priv, false);
  return {
    privHex: bytesToHex(priv),
    wif:     toWIF(priv, true),
    wifU:    toWIF(priv, false),
    addrs: {
      legacyC:  pubToLegacy(pubC),
      legacyU:  pubToLegacy(pubU),
      p2sh:     pubToP2SH(pubC),
      native:   pubToNative(pubC),
    },
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BIP39 + BIP32  ‚Äî mnemonic ‚Üí m/44'/0'/0'/0/0
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const N_SECP = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;

function u32BE(n) {
  return [(n >>> 24) & 0xff, (n >>> 16) & 0xff, (n >>> 8) & 0xff, n & 0xff];
}

async function deriveBip39(mnemonic) {
  const enc  = new TextEncoder();
  const mn   = enc.encode(mnemonic.normalize('NFKD'));
  const salt = enc.encode('mnemonic');

  const km  = await crypto.subtle.importKey('raw', mn, { name: 'PBKDF2' }, false, ['deriveBits']);
  const buf = await crypto.subtle.deriveBits(
    { name: 'PBKDF2', salt, iterations: 2048, hash: 'SHA-512' }, km, 512
  );
  const seed = new Uint8Array(buf);

  // BIP32 master key
  const I0   = hmac(sha512, enc.encode('Bitcoin seed'), seed);
  let priv   = I0.slice(0, 32);
  let chain  = I0.slice(32);

  // m/44'/0'/0'/0/0
  for (const idx of [0x8000002c, 0x80000000, 0x80000000, 0, 0]) {
    const hard = idx >= 0x80000000;
    const data = hard
      ? new Uint8Array([0x00, ...priv, ...u32BE(idx)])
      : new Uint8Array([...secp256k1.getPublicKey(priv, true), ...u32BE(idx)]);
    const Ic  = hmac(sha512, chain, data);
    const IL  = Ic.slice(0, 32);
    chain     = Ic.slice(32);
    const child = (BigInt('0x' + bytesToHex(IL)) + BigInt('0x' + bytesToHex(priv))) % N_SECP;
    priv = hexToBytes(child.toString(16).padStart(64, '0'));
  }

  const pubC = secp256k1.getPublicKey(priv, true);
  return {
    privHex: bytesToHex(priv),
    wif:     toWIF(priv, true),
    addrs: {
      legacyC: pubToLegacy(pubC),
      native:  pubToNative(pubC),
    },
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  WORD VARIATIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function generateVariations(word, dep) {
  const w  = word.trim();
  const wl = w.toLowerCase();
  const wu = w.toUpperCase();
  const wc = wl[0].toUpperCase() + wl.slice(1);
  const leet = wl
    .replace(/a/g,'4').replace(/e/g,'3').replace(/i/g,'1')
    .replace(/o/g,'0').replace(/s/g,'5').replace(/t/g,'7');

  const out = new Set([w, wl, wu, wc]);
  if (leet !== wl) out.add(leet);

  // Suffixes
  for (const s of ['1','2','12','123','1234','12345','!','!!','123!','007','69','420']) {
    out.add(wl + s);
  }
  // Bitcoin era years
  for (const y of ['2009','2010','2011','2012','2013']) out.add(wl + y);

  // Prefixes
  for (const p of ['my', 'the', 'i']) out.add(p + wl);

  if (dep === 'deep') {
    // All years 2009‚Äì2023
    for (let y = 2009; y <= 2023; y++) { out.add(wl + y); out.add(y + wl); }
    // Double
    out.add(wl + wl);
    // Leet with suffixes
    for (const s of ['1','123','!','2009','2010','2011']) out.add(leet + s);
    // Capitalized leet
    out.add(leet[0].toUpperCase() + leet.slice(1));
    // Alternating caps
    out.add([...wl].map((c, i) => i % 2 === 0 ? c.toUpperCase() : c).join(''));
    // Space / separator variants
    if (w.includes(' ')) {
      out.add(w.replace(/\s+/g, ''));
      out.add(w.replace(/\s+/g, '_'));
      out.add(w.replace(/\s+/g, '.'));
      out.add(w.replace(/\s+/g, '-'));
      out.add(w.replace(/\s+/g, ''));
    }
    // Extra lucky numbers
    for (const n of ['777','666','88','99','2017','2018','2020','2021']) out.add(wl + n);
  }

  return [...out].filter(v => v.length > 0 && v.length <= 80);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BALANCE CHECKER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function checkBalances(addresses) {
  if (!addresses.length) return {};
  const res = {};

  // ‚îÄ‚îÄ blockchain.info multiaddr (batch, handles all address types) ‚îÄ‚îÄ
  try {
    const url  = `https://blockchain.info/multiaddr?active=${addresses.join('|')}&n=0`;
    const resp = await fetch(url, { signal: AbortSignal.timeout(12000) });
    if (resp.ok) {
      const data = await resp.json();
      for (const a of (data.addresses || [])) {
        res[a.address] = { balance: a.final_balance / 1e8, txCount: a.n_tx };
      }
      for (const addr of addresses) {
        if (!res[addr]) res[addr] = { balance: 0, txCount: 0 };
      }
      return res;
    }
  } catch (_) { /* fall through to blockstream */ }

  // ‚îÄ‚îÄ blockstream.info fallback (individual queries) ‚îÄ‚îÄ
  for (const addr of addresses) {
    if (res[addr]) continue;
    try {
      const resp = await fetch(
        `https://blockstream.info/api/address/${addr}`,
        { signal: AbortSignal.timeout(8000) }
      );
      if (resp.ok) {
        const d   = await resp.json();
        const bal = (d.chain_stats.funded_txo_sum - d.chain_stats.spent_txo_sum) / 1e8;
        res[addr] = { balance: bal, txCount: d.chain_stats.tx_count };
      } else {
        res[addr] = { balance: 0, txCount: 0 };
      }
    } catch (_) {
      res[addr] = { balance: 0, txCount: 0 };
    }
    await sleep(100);
  }

  return res;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UI HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateStats() {
  byId('sWords').textContent = stats.words.toLocaleString();
  byId('sVars').textContent  = stats.vars.toLocaleString();
  byId('sAddrs').textContent = stats.addrs.toLocaleString();
  byId('sFound').textContent = stats.found;
}

function ts() {
  return new Date().toLocaleTimeString('en', { hour12: false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
}

function addFeed(msg, cls = 'fe-info') {
  const feed = byId('feed');
  byId('feedCard').classList.remove('hidden');
  const el  = document.createElement('div');
  el.className = `feed-entry ${cls}`;
  const tsEl = document.createElement('span');
  tsEl.className = 'fe-ts';
  tsEl.textContent = ts();
  el.appendChild(tsEl);
  el.appendChild(document.createTextNode(' ' + msg));
  feed.appendChild(el);
  feed.scrollTop = feed.scrollHeight;
  return el;
}

function updateLastFeed(msg, cls) {
  const feed = byId('feed');
  const last = feed.lastElementChild;
  if (!last) return;
  last.className = `feed-entry ${cls}`;
  const tsEl = last.querySelector('.fe-ts');
  last.textContent = '';
  if (tsEl) last.appendChild(tsEl);
  last.appendChild(document.createTextNode(' ' + msg));
}

function addHuntFeed(msg, cls = 'fe-info') {
  const feed = byId('huntFeed');
  const el   = document.createElement('div');
  el.className = `feed-entry ${cls}`;
  el.textContent = `${ts()} ${msg}`;
  feed.appendChild(el);
  while (feed.children.length > 200) feed.removeChild(feed.firstChild);
  feed.scrollTop = feed.scrollHeight;
}

function setProgress(pct) {
  const wrap = byId('progWrap');
  const bar  = byId('progBar');
  wrap.classList.remove('hidden');
  if (pct < 0) {
    bar.classList.add('ind');
  } else {
    bar.classList.remove('ind');
    bar.style.width = pct + '%';
  }
  if (pct >= 100) setTimeout(() => wrap.classList.add('hidden'), 600);
}

function showToast(msg, dur = 2800) {
  const t = byId('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), dur);
}

function showResult(label, addr, balance, txCount, keyInfo) {
  const card = byId('resultsCard');
  card.classList.remove('hidden');

  const btc  = typeof balance === 'number' ? balance.toFixed(8) : String(balance);
  const eurl = addr.startsWith('bc1')
    ? `https://blockstream.info/address/${addr}`
    : `https://www.blockchain.com/explorer/addresses/btc/${addr}`;

  const div  = document.createElement('div');
  div.className = 'result-item';

  // Balance
  const balDiv = document.createElement('div');
  balDiv.className = 'result-bal';
  balDiv.textContent = `${btc} BTC`;
  div.appendChild(balDiv);

  // Helper: row with label, value, copy btn, optional link
  const addRow = (lbl, val, link) => {
    const row  = document.createElement('div');
    row.className = 'result-field';

    const l = document.createElement('span'); l.className = 'rf-lbl'; l.textContent = lbl;
    const v = document.createElement('span'); v.className = 'rf-val'; v.textContent = val;
    const c = document.createElement('button'); c.className = 'copy-btn'; c.textContent = 'Copy';
    c.addEventListener('click', () => navigator.clipboard.writeText(val).then(() => showToast('‚úì Copied!')));

    row.appendChild(l); row.appendChild(v); row.appendChild(c);
    if (link) {
      const a = document.createElement('a');
      a.className = 'expl-link'; a.href = link; a.target = '_blank'; a.rel = 'noopener';
      a.textContent = 'Explorer ‚Üó';
      row.appendChild(a);
    }
    div.appendChild(row);
  };

  addRow('Passphrase', label);
  addRow('Address', addr, eurl);
  if (keyInfo.wif)     addRow('WIF (comp)', keyInfo.wif);
  if (keyInfo.wifU)    addRow('WIF (uncomp)', keyInfo.wifU);
  if (keyInfo.privHex) addRow('Priv Key', keyInfo.privHex);

  if (txCount > 0) {
    const info = document.createElement('div');
    info.style.cssText = 'font-size:12px;color:var(--text2);margin-top:8px';
    info.textContent = `${txCount} transaction(s) recorded on this address`;
    div.appendChild(info);
  }

  const warn = document.createElement('div');
  warn.style.cssText = 'font-size:11px;color:var(--danger);margin-top:8px';
  warn.textContent = '‚ö†Ô∏è Save this key immediately ‚Äî it is not stored anywhere';
  div.appendChild(warn);

  byId('resultsList').prepend(div);

  stats.found++;
  byId('foundBadge').textContent = stats.found;
  updateStats();

  card.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TOGGLE CONTROLS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setMode(m) {
  mode = m;
  byId('modeBW').classList.toggle('active',  m === 'brainwallet');
  byId('modeBIP').classList.toggle('active', m === 'bip39');
  byId('modeHint').textContent = m === 'brainwallet'
    ? "Brain wallet: SHA256(passphrase) ‚Üí private key ¬∑ checks Legacy, P2SH-SegWit & Native SegWit addresses"
    : "BIP39 seed: PBKDF2(2048) + BIP32 m/44'/0'/0'/0/0 ¬∑ slower, checks Legacy & Native SegWit";
}
function setDepth(d) {
  depth = d;
  byId('depthN').classList.toggle('active', d === 'normal');
  byId('depthD').classList.toggle('active', d === 'deep');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MAIN CHECK FLOW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function startCheck() {
  const word = byId('wordInput').value.trim();
  if (!word)       { showToast('Enter a word or phrase first'); return; }
  if (isChecking)  return;

  isChecking = true;
  stopCheck  = false;

  byId('btnCheck').classList.add('hidden');
  byId('btnStop').classList.remove('hidden');
  byId('btnStop').textContent = '‚èπ Stop';
  byId('statusBadge').innerHTML = '<span class="pulse"></span> Running';
  byId('statusBadge').className = 'badge badge-run';

  const vars = generateVariations(word, depth);
  stats.vars += vars.length;
  updateStats();

  addFeed(`üîç "${word}" ‚Äî ${vars.length} variations (${mode}, ${depth})`, 'fe-info');

  for (let i = 0; i < vars.length; i++) {
    if (stopCheck) break;

    const v = vars[i];
    setProgress(Math.round(i / vars.length * 100));

    let keyInfo, addrs;
    try {
      if (mode === 'brainwallet') {
        keyInfo = deriveBrainWallet(v);
        addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
      } else {
        keyInfo = await deriveBip39(v);
        addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.native];
      }
    } catch (e) {
      addFeed(`Error deriving "${v}": ${e.message}`, 'fe-error');
      continue;
    }

    addFeed(`Checking: "${v}"‚Ä¶`, 'fe-checking');

    let bals;
    try {
      bals = await checkBalances(addrs);
    } catch (e) {
      updateLastFeed(`‚ö†Ô∏è API error for "${v}"`, 'fe-error');
      await sleep(1000);
      continue;
    }

    stats.addrs += addrs.length;

    let anyBal  = false;
    let anyUsed = false;
    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        anyBal = true;
        showResult(v, addr, info.balance, info.txCount, keyInfo);
        addFeed(`üèÜ BALANCE: "${v}" ‚Üí ${addr} ‚Äî ${info.balance.toFixed(8)} BTC`, 'fe-found');
      } else if (info.txCount > 0 && !anyBal) {
        anyUsed = true;
      }
    }

    if (!anyBal) {
      if (anyUsed) {
        updateLastFeed(`üëÅ "${v}" ‚Äî used (0 BTC, already swept)`, 'fe-used');
      } else {
        updateLastFeed(`‚ùå "${v}" ‚Äî empty`, 'fe-empty');
      }
    }

    stats.words++;
    updateStats();

    await sleep(mode === 'bip39' ? 600 : 250);
  }

  setProgress(100);
  addFeed(stopCheck
    ? `‚èπ Stopped ‚Äî ${stats.words} variations tried`
    : `‚úÖ Done ‚Äî all ${vars.length} variations checked`,
    'fe-info'
  );

  isChecking = false;
  byId('btnCheck').classList.remove('hidden');
  byId('btnStop').classList.add('hidden');
  byId('statusBadge').textContent = '‚è∏ Idle';
  byId('statusBadge').className = 'badge badge-idle';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RANDOM KEY HUNT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function startHunt(count) {
  if (isHunting) return;
  isHunting = true;
  stopHunt  = false;

  ['bH10','bH100','bH1000'].forEach(id => byId(id).disabled = true);
  byId('bHStop').classList.remove('hidden');
  byId('bHStop').textContent = '‚èπ Stop';

  addHuntFeed(`üé∞ Starting hunt ‚Äî ${count} random keys`, 'fe-info');

  let thisFound = 0;

  for (let i = 0; i < count; i++) {
    if (stopHunt) break;

    const privBytes = crypto.getRandomValues(new Uint8Array(32));

    let pubC;
    try {
      pubC = secp256k1.getPublicKey(privBytes, true);
    } catch (_) {
      continue; // invalid scalar (astronomically rare)
    }

    const legacy = pubToLegacy(pubC);
    const native = pubToNative(pubC);

    addHuntFeed(`[${i + 1}/${count}] ${legacy.slice(0, 14)}‚Ä¶ checking‚Ä¶`, 'fe-checking');

    let bals;
    try {
      bals = await checkBalances([legacy, native]);
    } catch (_) {
      await sleep(500);
      continue;
    }

    stats.keys++;
    stats.addrs += 2;
    updateStats();

    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        thisFound++;
        const ki = { privHex: bytesToHex(privBytes), wif: toWIF(privBytes, true), wifU: toWIF(privBytes, false) };
        showResult(`RANDOM KEY #${stats.keys}`, addr, info.balance, info.txCount, ki);
        addHuntFeed(`üé∞ JACKPOT! ${addr} ‚Äî ${info.balance.toFixed(8)} BTC`, 'fe-jackpot');
      }
    }

    await sleep(420);
  }

  addHuntFeed(
    stopHunt
      ? `‚èπ Hunt stopped ‚Äî ${stats.keys} total keys hunted, ${thisFound} found this run`
      : `‚úÖ Complete ‚Äî ${count} keys checked, ${thisFound} found`,
    'fe-info'
  );

  isHunting = false;
  ['bH10','bH100','bH1000'].forEach(id => byId(id).disabled = false);
  byId('bHStop').classList.add('hidden');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BATCH MODE TOGGLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setBatchMode(m) {
  batchMode = m;
  byId('batchModeBW').classList.toggle('active',  m === 'brainwallet');
  byId('batchModeBIP').classList.toggle('active', m === 'bip39');
}
function setBatchDepth(d) {
  batchDepth = d;
  byId('batchDepthN').classList.toggle('active', d === 'normal');
  byId('batchDepthD').classList.toggle('active', d === 'deep');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BATCH CHECK FLOW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function startBatch() {
  const raw = byId('batchInput').value.trim();
  if (!raw) { showToast('Paste some words first'); return; }
  if (isBatching) return;

  const words = [...new Set(raw.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0 && w.length <= 80))];
  if (words.length === 0) { showToast('No valid words found'); return; }

  isBatching = true;
  stopBatchFlag = false;

  byId('btnBatchCheck').classList.add('hidden');
  byId('btnBatchStop').classList.remove('hidden');
  byId('btnBatchStop').textContent = '‚èπ Stop';
  byId('batchFeedCard').classList.remove('hidden');

  const feed = byId('batchFeed');
  feed.innerHTML = '';

  let wordsDone = 0;

  function batchFeedLine(msg, cls = 'fe-info') {
    const el = document.createElement('div');
    el.className = `feed-entry ${cls}`;
    el.textContent = `${ts()} ${msg}`;
    feed.appendChild(el);
    while (feed.children.length > 300) feed.removeChild(feed.firstChild);
    feed.scrollTop = feed.scrollHeight;
    return el;
  }
  function updateBatchLast(msg, cls) {
    const last = feed.lastElementChild;
    if (!last) return;
    last.className = `feed-entry ${cls}`;
    last.textContent = `${ts()} ${msg}`;
  }

  batchFeedLine(`üîç Batch: ${words.length} words ¬∑ mode=${batchMode} ¬∑ depth=${batchDepth}`, 'fe-info');

  for (let wi = 0; wi < words.length; wi++) {
    if (stopBatchFlag) break;

    const word = words[wi];
    byId('batchProgress').textContent = `${wi + 1} / ${words.length}`;

    const pct = Math.round(wi / words.length * 100);
    byId('batchProgWrap').classList.remove('hidden');
    byId('batchProgBar').style.width = pct + '%';

    const vars = generateVariations(word, batchDepth);
    stats.vars += vars.length;

    for (let vi = 0; vi < vars.length; vi++) {
      if (stopBatchFlag) break;

      const v = vars[vi];
      let keyInfo, addrs;
      try {
        if (batchMode === 'brainwallet') {
          keyInfo = deriveBrainWallet(v);
          addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
        } else {
          keyInfo = await deriveBip39(v);
          addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.native];
        }
      } catch (e) { continue; }

      batchFeedLine(`[${wi+1}/${words.length}] "${v}"‚Ä¶`, 'fe-checking');

      let bals;
      try { bals = await checkBalances(addrs); } catch(e) { await sleep(500); continue; }

      stats.addrs += addrs.length;

      let anyBal = false, anyUsed = false;
      for (const [addr, info] of Object.entries(bals)) {
        if (info.balance > 0) {
          anyBal = true;
          showResult(v, addr, info.balance, info.txCount, keyInfo);
          batchFeedLine(`üèÜ FOUND: "${v}" ‚Üí ${info.balance.toFixed(8)} BTC`, 'fe-found');
        } else if (info.txCount > 0 && !anyBal) {
          anyUsed = true;
        }
      }
      if (!anyBal) {
        updateBatchLast(
          anyUsed ? `üëÅ "${v}" ‚Äî used (0 BTC, swept)` : `‚ùå "${v}" ‚Äî empty`,
          anyUsed ? 'fe-used' : 'fe-empty'
        );
      }

      stats.words++;
      updateStats();
      await sleep(batchMode === 'bip39' ? 600 : 250);
    }

    wordsDone++;
  }

  byId('batchProgBar').style.width = '100%';
  byId('batchProgress').textContent = `Done ‚Äî ${wordsDone} words`;
  batchFeedLine(
    stopBatchFlag ? `‚èπ Stopped ‚Äî ${wordsDone} of ${words.length} words` : `‚úÖ Batch complete ‚Äî ${words.length} words`,
    'fe-info'
  );

  isBatching = false;
  byId('btnBatchCheck').classList.remove('hidden');
  byId('btnBatchStop').classList.add('hidden');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  KEYBOARD SHORTCUT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
byId('wordInput').addEventListener('keydown', e => {
  if (e.key === 'Enter' && !isChecking) startCheck();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  URL PARAM DEEP LINKING ‚Äî auto-fill & auto-start
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function initFromUrlParams() {
  const params = new URLSearchParams(location.search);
  const word   = params.get('word');
  const words  = params.get('words');
  const modeP  = params.get('mode');
  const depthP = params.get('depth');
  const tab    = params.get('tab');

  // Apply mode / depth overrides first
  if (modeP === 'bip39' || modeP === 'brainwallet') {
    setMode(modeP);
    setBatchMode(modeP);
  }
  if (depthP === 'deep' || depthP === 'normal') {
    setDepth(depthP);
    setBatchDepth(depthP);
  }

  if (words) {
    // Batch tab: pre-fill textarea and auto-start
    switchTab('batch');
    byId('batchInput').value = words.replace(/,/g, '\n');
    byId('batchFeedCard').classList.remove('hidden');
    setTimeout(() => startBatch(), 700);

  } else if (word) {
    // Single word tab: pre-fill and auto-start
    switchTab('single');
    byId('wordInput').value = word;
    setTimeout(() => startCheck(), 500);

  } else if (tab === 'batch') {
    switchTab('batch');
  } else if (tab === 'hunt') {
    switchTab('hunt');
  } else if (tab === 'memory') {
    switchTab('memory');
  } else if (tab === 'ai') {
    switchTab('ai');
  } else if (tab === 'keys') {
    switchTab('keys');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MEMORY GUIDE ‚Äî DATA
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MEM_TOPIC_WORDS = {
  gaming:  ['minecraft','warcraft','starcraft','skyrim','steam','halflife','counter','quake','doom','zelda','mario','sonic','pokemon','fortnite','wow','lol','halo','diablo','runescape'],
  movies:  ['matrix','batman','inception','avatar','titanic','darth','vader','jedi','sith','hobbit','harry','potter','stark','joker','avengers','godfather','gladiator','shrek','terminator'],
  sports:  ['football','soccer','basketball','messi','ronaldo','jordan','lakers','yankees','chelsea','barcelona','nfl','nba','champion','winner','trophy','referee','penalty','scoreboard'],
  music:   ['metallica','nirvana','beatles','eminem','skrillex','dubstep','guitar','piano','rockstar','metal','jazz','rapper','melody','linkin','park','radiohead','coldplay'],
  crypto:  ['bitcoin','satoshi','nakamoto','blockchain','halving','hodl','moon','lambo','defi','nft','mining','hash','genesis','block','crypto','btc','miner','wallet'],
  nature:  ['dragon','wolf','tiger','eagle','phoenix','lion','cobra','falcon','shark','thunder','storm','shadow','darkness','fire','ice','mountain','ocean','forest','thunder'],
  personal:['love','family','forever','secret','lucky','dream','hope','angel','heart','faith','trust','power','freedom','peace','victory','sunrise','destiny','spirit'],
  work:    ['admin','password','server','database','deploy','backend','devops','engineer','manager','office','project','system','network','cloud','docker','code','linux'],
};
const YEAR_WORDS = {
  '2009': ['genesis','satoshi','nakamoto','first','pioneer','bitcoin','original'],
  '2010': ['pizza','laszlo','hanyecz','exchange','dollar'],
  '2011': ['silk','road','wikileaks','anonymous'],
  '2012': ['halving','halvening'],
  '2013': ['cyprus','mtgox','silkroad','ross'],
  '2014': ['gox','collapse','ethereum','vitalik'],
  '2015': ['eth','ethereum','smart','contract'],
  '2016': ['dao','hack','fork','classic'],
  '2017': ['boom','altseason','ico','bull','moon','lambo'],
  '2018': ['crash','bear','market'],
  '2019': ['libra','facebook','bakkt','futures'],
  '2020': ['halving','pandemic','defi','summer'],
  '2021': ['nft','bull','ath','laser','eyes'],
  '2022': ['luna','ftx','crash','celsius'],
  '2023': ['etf','spot','approve'],
};
const COMMON_BRAIN_WALLETS = [
  'password','bitcoin','satoshi','1234','qwerty','test','hello','secret',
  'abc123','letmein','monkey','dragon','master','admin','welcome','login',
  'pass','love','money','freedom','matrix','blockchain','private','nakamoto',
  'god','correct horse battery staple','this is a test','to be or not to be',
  'bitcoin is freedom','the quick brown fox','i am satoshi nakamoto','genesis',
];

let memAnswers = { year: null, topic: null, platform: null, hint: '' };
let memStep    = 0;
let memWordList = [];
let aiWordList  = [];
let isLucky    = false;
let isAIGen    = false;
const checkedWordsSession = new Set();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MEMORY GUIDE ‚Äî FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function memAnswer(key, value) {
  memAnswers[key] = value;
  document.querySelectorAll(`[data-mem="${key}"]`).forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(value));
  });
  setTimeout(() => {
    if (key === 'year')     showMemStep(1);
    if (key === 'topic')    showMemStep(2);
    if (key === 'platform') showMemStep(3);
  }, 300);
}

function showMemStep(step) {
  memStep = step;
  for (let i = 0; i < 4; i++) {
    const p = byId(`memStep${i}`);
    if (p) p.classList.toggle('hidden', i !== step);
  }
  document.querySelectorAll('.step-dot').forEach((dot, i) => {
    dot.className = 'step-dot' + (i < step ? ' done' : i === step ? ' active' : '');
  });
}

function generateMemoryWords() {
  const words = new Set(COMMON_BRAIN_WALLETS.slice(0, 8));
  if (memAnswers.topic && MEM_TOPIC_WORDS[memAnswers.topic]) {
    MEM_TOPIC_WORDS[memAnswers.topic].forEach(w => words.add(w));
  }
  if (memAnswers.year && YEAR_WORDS[memAnswers.year]) {
    YEAR_WORDS[memAnswers.year].forEach(w => words.add(w));
    words.add(String(memAnswers.year));
  }
  if (memAnswers.hint) {
    memAnswers.hint.trim().split(/\s+/).forEach(w => { if (w.length > 0) words.add(w.toLowerCase()); });
  }
  if (memAnswers.platform === 'windows') {
    [...words].slice(0, 6).forEach(w => { words.add(w + '1'); words.add(w + '123'); });
  } else if (memAnswers.platform === 'mobile') {
    [...words].slice(0, 6).forEach(w => { words.add(w + '007'); words.add(w + '2021'); });
  }
  return [...words].filter(w => w.length > 0 && w.length <= 60);
}

function updateMemWordCloud() {
  memWordList = generateMemoryWords();
  const cloud = byId('memWordCloud');
  cloud.innerHTML = '';
  memWordList.forEach(w => {
    const tag = document.createElement('span');
    tag.className = 'mem-word-tag';
    tag.textContent = w;
    cloud.appendChild(tag);
  });
  byId('memWordCount').textContent = `${memWordList.length} words`;
  byId('memResultsSection').classList.remove('hidden');
}

function sendMemToBatch() {
  if (!memWordList.length) return;
  switchTab('batch');
  byId('batchInput').value = memWordList.join('\n');
  showToast(`‚úì ${memWordList.length} memory words sent to Batch`);
}

function resetMemWizard() {
  memAnswers = { year: null, topic: null, platform: null, hint: '' };
  document.querySelectorAll('.mem-btn').forEach(b => b.classList.remove('active'));
  byId('memHintInput').value = '';
  byId('memResultsSection').classList.add('hidden');
  showMemStep(0);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FEELING LUCKY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function feelingLucky() {
  if (isLucky) return;
  isLucky = true;
  const luckyBtn = byId('btnLucky');
  luckyBtn.disabled = true;
  luckyBtn.textContent = 'üçÄ Checking‚Ä¶';

  const candidates = [...new Set([
    ...COMMON_BRAIN_WALLETS,
    ...(memWordList.length ? memWordList : []),
    ...(aiWordList.length  ? aiWordList  : []),
  ])].filter(w => !checkedWordsSession.has(w)).slice(0, 12);

  const grid = byId('luckyGrid');
  grid.innerHTML = '';

  // Reveal cards one by one
  const cards = [];
  for (const w of candidates) {
    await sleep(70);
    const el = document.createElement('div');
    el.className = 'lucky-word';
    el.textContent = w;
    grid.appendChild(el);
    cards.push({ el, word: w });
  }

  await sleep(350);

  for (const { el, word } of cards) {
    el.classList.add('checking');
    el.textContent = `üîç ${word}`;
    checkedWordsSession.add(word);

    let keyInfo, addrs;
    try {
      keyInfo = deriveBrainWallet(word);
      addrs = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
    } catch (_) {
      el.classList.remove('checking'); el.classList.add('empty'); el.textContent = word; continue;
    }

    let bals;
    try { bals = await checkBalances(addrs); }
    catch (_) { el.classList.remove('checking'); el.classList.add('empty'); el.textContent = word; continue; }

    stats.addrs += addrs.length;
    stats.words++;
    updateStats();

    let found = false;
    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        found = true;
        showResult(word, addr, info.balance, info.txCount, keyInfo);
        el.classList.remove('checking'); el.classList.add('found');
        el.textContent = `üèÜ ${word}`;
        showToast('üèÜ Found a wallet!', 5000);
      }
    }
    if (!found) {
      const anyUsed = Object.values(bals).some(i => i.txCount > 0);
      el.classList.remove('checking');
      el.classList.add(anyUsed ? 'used' : 'empty');
      el.textContent = anyUsed ? `üëÅ ${word}` : word;
    }
    await sleep(280);
  }

  isLucky = false;
  luckyBtn.disabled = false;
  luckyBtn.textContent = 'üçÄ Try Again';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AI SUGGEST
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function detectAIProvider(val) {
  const badge = byId('aiProviderBadge');
  if (val.startsWith('gsk_')) {
    badge.textContent = '‚ö° Groq (free)'; badge.style.color = 'var(--success)';
  } else if (val.startsWith('sk-')) {
    badge.textContent = 'ü§ñ OpenAI'; badge.style.color = 'var(--accent)';
  } else {
    badge.textContent = 'Auto-detect'; badge.style.color = '';
  }
}

async function callAI(apiKey, prompt, maxTokens = 400) {
  const isOpenAI = apiKey.startsWith('sk-') && !apiKey.startsWith('sk-gsk');
  const endpoint = isOpenAI
    ? 'https://api.openai.com/v1/chat/completions'
    : 'https://api.groq.com/openai/v1/chat/completions';
  const model = isOpenAI ? 'gpt-4o-mini' : 'llama-3.3-70b-versatile';

  const resp = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: maxTokens,
      temperature: 0.7,
    }),
    signal: AbortSignal.timeout(25000),
  });
  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`AI error ${resp.status}: ${err.slice(0, 120)}`);
  }
  return (await resp.json()).choices[0].message.content.trim();
}

async function generateAIWords() {
  const apiKey  = byId('aiApiKey').value.trim();
  const context = byId('aiContext').value.trim();
  if (!apiKey) { showToast('Enter a Groq or OpenAI API key first'); return; }
  if (isAIGen) return;
  isAIGen = true;

  const btn = byId('btnAIGenerate');
  btn.disabled = true;
  btn.textContent = '‚è≥ Generating‚Ä¶';
  byId('aiWordCloud').innerHTML = '';
  byId('aiResultsSection').classList.add('hidden');

  const prompt = `You are helping recover a forgotten Bitcoin brain wallet passphrase.
Context from the wallet owner: ${context || 'general Bitcoin user from 2011-2017'}

Generate 25-35 candidate passphrases they might have used. Include:
- Common words/phrases related to the context
- Bitcoin-era slang and references
- Simple passwords with common modifications
- Names, places, or hobbies related to their context

Reply with ONLY a JSON array of strings, no explanation.
Example: ["word1","phrase two","another phrase"]`;

  try {
    const text = await callAI(apiKey, prompt);
    const match = text.match(/\[[\s\S]*\]/);
    if (!match) throw new Error('AI returned unexpected format');
    aiWordList = JSON.parse(match[0])
      .filter(w => typeof w === 'string' && w.length > 0 && w.length <= 80);

    const cloud = byId('aiWordCloud');
    cloud.innerHTML = '';
    aiWordList.forEach(w => {
      const tag = document.createElement('span');
      tag.className = 'ai-word-tag';
      tag.textContent = w;
      cloud.appendChild(tag);
    });
    byId('aiWordCount').textContent = `${aiWordList.length} words`;
    byId('aiResultsSection').classList.remove('hidden');
    showToast(`‚úì AI generated ${aiWordList.length} candidates`);
  } catch (e) {
    showToast(`‚ùå ${e.message.slice(0, 70)}`);
  }

  isAIGen = false;
  btn.disabled = false;
  btn.textContent = 'ü§ñ Generate Words';
}

function sendAIToBatch() {
  if (!aiWordList.length) return;
  switchTab('batch');
  byId('batchInput').value = aiWordList.join('\n');
  showToast(`‚úì ${aiWordList.length} AI words sent to Batch`);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DICTIONARY PRESETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const DICT_PRESETS = {
  common: ['password','123456','qwerty','letmein','monkey','dragon','master','welcome','admin','pass','test','hello','secret','abc123','trustno1','iloveyou','sunshine','princess','baseball','football','shadow','superman','batman','internet','1234567890'],
  crypto: ['bitcoin','satoshi','nakamoto','blockchain','halving','hodl','moonlambo','cryptocurrency','genesis','privkey','wallet','mnemonic','btc2013','crypto2017','defi','nft','mining','hash','lightning','segwit','taproot','ethereum','vitalik','buterik'],
  pop:    ['matrix','inception','starwars','darkside','harrypotter','hermione','voldemort','hobbit','frodo','baggins','batman','superman','spiderman','ironman','thanos','avengers','gameofthrones','breakingbad','walterwhite','heisenberg','minecraft','fortnite'],
};

// ‚îÄ‚îÄ‚îÄ Graveyard data ‚Äî famous cracked brain wallets (educational only) ‚îÄ‚îÄ‚îÄ
const GRAVEYARD_DATA = [
  { pass: 'password',                    crackTime: '<1 ms', year: '2013', note: '#1 most used password ever' },
  { pass: 'bitcoin',                     crackTime: '<1 ms', year: '2012', note: 'first word attackers try' },
  { pass: 'satoshi',                     crackTime: '<1 ms', year: '2012', note: "creator's name ‚Äî obvious" },
  { pass: '1',                           crackTime: '<1 ms', year: '2011', note: 'single digit ‚Äî in every list' },
  { pass: 'abc',                         crackTime: '<1 ms', year: '2011', note: 'trivial 3-char sequence' },
  { pass: 'hello',                       crackTime: '<1 ms', year: '2012', note: 'in every wordlist ever' },
  { pass: 'qwerty',                      crackTime: '<1 ms', year: '2013', note: 'keyboard pattern' },
  { pass: 'brainwallet',                 crackTime: '<1 ms', year: '2013', note: 'literally named the attack' },
  { pass: 'correct horse battery staple', crackTime: '<1 ms', year: '2013', note: 'famous xkcd ‚Äî widely known' },
  { pass: 'this is a test',             crackTime: '<1 ms', year: '2013', note: 'common test phrase' },
  { pass: 'sausage',                     crackTime: '~2 ms', year: '2014', note: 'dictionary word attack' },
  { pass: 'i am satoshi nakamoto',       crackTime: '~5 ms', year: '2014', note: 'phrase from known wordlists' },
  { pass: 'to be or not to be',         crackTime: '~5 ms', year: '2014', note: 'famous literary quote' },
  { pass: 'nakamoto',                    crackTime: '<1 ms', year: '2012', note: "Satoshi's surname alone" },
  { pass: 'genesis',                     crackTime: '<1 ms', year: '2013', note: 'Bitcoin genesis block ref.' },
  { pass: 'hunter2',                     crackTime: '<1 ms', year: '2013', note: 'famous IRC "password"' },
];

function loadDictPreset(name) {
  let words = [];
  if (name === 'shame') {
    words = GRAVEYARD_DATA.map(d => d.pass);
  } else if (DICT_PRESETS[name]) {
    words = DICT_PRESETS[name];
  }
  if (!words.length) return;
  switchTab('batch');
  byId('batchInput').value = words.join('\n');
  showToast(`‚úì Loaded ${words.length} words`);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  KEY INSPECTOR & ENTROPY GENERATOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderKeyInfo(container, hexKey, wifC, wifU, legacy, legacyU, p2sh, native) {
  const fields = [
    { lbl: 'Private Key (hex)', val: hexKey  },
    { lbl: 'WIF (compressed)',  val: wifC    },
    { lbl: 'WIF (uncompr.)',    val: wifU    },
    { lbl: 'Legacy P2PKH',     val: legacy  },
    { lbl: 'Legacy (uncompr.)',val: legacyU },
    { lbl: 'P2SH-SegWit',      val: p2sh    },
    { lbl: 'Native SegWit',    val: native  },
  ];
  container.innerHTML = '';
  for (const { lbl, val } of fields) {
    const row   = document.createElement('div'); row.className = 'result-field';
    const lblEl = document.createElement('span'); lblEl.className = 'rf-lbl'; lblEl.textContent = lbl;
    const valEl = document.createElement('span'); valEl.className = 'rf-val'; valEl.textContent = val;
    const cpyEl = document.createElement('button'); cpyEl.className = 'copy-btn'; cpyEl.textContent = 'Copy';
    cpyEl.onclick = () => navigator.clipboard.writeText(val).then(() => showToast('‚úì Copied'));
    row.append(lblEl, valEl, cpyEl);
    container.appendChild(row);
  }
  // Balance check button
  const btnRow = document.createElement('div'); btnRow.className = 'btn-row'; btnRow.style.marginTop = '14px';
  const chkBtn = document.createElement('button'); chkBtn.className = 'btn btn-secondary'; chkBtn.textContent = '‚ö° Check Balance';
  chkBtn.onclick = async () => {
    chkBtn.disabled = true; chkBtn.textContent = '‚è≥ Checking‚Ä¶';
    try {
      const bals = await checkBalances([legacy, legacyU, p2sh, native]);
      stats.addrs += 4; updateStats();
      let found = false;
      for (const [addr, info] of Object.entries(bals)) {
        if (info.balance > 0) {
          found = true;
          showResult(hexKey.slice(0,8) + '‚Ä¶', addr, info.balance, info.txCount, {
            privHex: hexKey, wif: wifC, wifU, addrs: { legacyC: legacy, legacyU, p2sh, native },
          });
          showToast('üèÜ Found balance!', 5000);
        }
      }
      if (!found) {
        const anyUsed = Object.values(bals).some(i => i.txCount > 0);
        showToast(anyUsed ? 'üëÅ Used address (swept)' : '‚úÖ All addresses empty');
      }
      chkBtn.textContent = '‚ö° Recheck';
    } catch(e) { showToast('‚ùå ' + e.message.slice(0,50)); chkBtn.textContent = '‚ö° Retry'; }
    chkBtn.disabled = false;
  };
  btnRow.appendChild(chkBtn);
  container.appendChild(btnRow);
}

function inspectKey() {
  const raw = byId('kiInput').value.trim();
  if (!raw) { showToast('Paste a private key first'); return; }
  let hexKey;
  try { hexKey = parsePrivKey(raw); }
  catch(e) { showToast('‚ùå ' + e.message.slice(0, 70)); return; }

  const privBytes = hexToBytes(hexKey);
  const pubC = secp256k1.getPublicKey(privBytes, true);
  const pubU = secp256k1.getPublicKey(privBytes, false);
  renderKeyInfo(
    byId('kiResultInner'), hexKey,
    toWIF(privBytes, true), toWIF(privBytes, false),
    pubToLegacy(pubC), pubToLegacy(pubU), pubToP2SH(pubC), pubToNative(pubC)
  );
  byId('kiResult').classList.remove('hidden');
}

function generateEntropyKey() {
  let privBytes;
  for (let i = 0; i < 100; i++) {
    const b = crypto.getRandomValues(new Uint8Array(32));
    const n = BigInt('0x' + bytesToHex(b));
    if (n > 0n && n < N_SECP) { privBytes = b; break; }
  }
  if (!privBytes) { showToast('Generation failed ‚Äî try again'); return; }

  const hexKey = bytesToHex(privBytes);
  const pubC   = secp256k1.getPublicKey(privBytes, true);
  const pubU   = secp256k1.getPublicKey(privBytes, false);
  renderKeyInfo(
    byId('entropyResultInner'), hexKey,
    toWIF(privBytes, true), toWIF(privBytes, false),
    pubToLegacy(pubC), pubToLegacy(pubU), pubToP2SH(pubC), pubToNative(pubC)
  );
  byId('entropyResult').classList.remove('hidden');
  showToast('‚úì New random key generated');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GRAVEYARD (educational ‚Äî no balance checking)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function initGraveyard() {
  const tbody = byId('graveyardBody');
  if (!tbody) return;
  GRAVEYARD_DATA.forEach(item => {
    let addrPreview = '‚Äî';
    try {
      const k = deriveBrainWallet(item.pass);
      addrPreview = k.addrs.legacyC.slice(0, 10) + '‚Ä¶';
    } catch(_) {}

    const tr     = document.createElement('tr');
    const tdPass = document.createElement('td'); tdPass.className = 'shame-pass'; tdPass.textContent = item.pass;
    const tdTime = document.createElement('td'); tdTime.className = 'shame-yr';   tdTime.textContent = item.crackTime;
    const tdYear = document.createElement('td'); tdYear.className = 'shame-yr';   tdYear.textContent = item.year;
    const tdAddr = document.createElement('td'); tdAddr.className = 'shame-yr';
    tdAddr.style.fontFamily = 'var(--mono)'; tdAddr.textContent = addrPreview;
    const tdNote = document.createElement('td');
    tdNote.style.cssText = 'color:var(--text3);font-size:10.5px'; tdNote.textContent = item.note;

    tr.append(tdPass, tdTime, tdYear, tdAddr, tdNote);
    tbody.appendChild(tr);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  KEYSPACE BROWSER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let ksPage = 1n;
let ksInitialized = false;
const KS_PER_PAGE = 20;

function renderKeyspacePage(page) {
  ksPage = page < 1n ? 1n : page;
  byId('ksPageInput').value = ksPage.toString();
  const tbody = byId('ksTableBody');
  tbody.innerHTML = '';

  for (let i = 0n; i < BigInt(KS_PER_PAGE); i++) {
    const keyNum = (ksPage - 1n) * BigInt(KS_PER_PAGE) + i + 1n;
    const keyHex = keyNum.toString(16).padStart(64, '0');

    let legacyAddr = '‚Äî', nativeAddr = '‚Äî';
    try {
      const privBytes = hexToBytes(keyHex);
      const pubC = secp256k1.getPublicKey(privBytes, true);
      legacyAddr = pubToLegacy(pubC);
      nativeAddr = pubToNative(pubC);
    } catch(_) {}

    const tr = document.createElement('tr');

    const tdNum  = document.createElement('td'); tdNum.className = 'ks-num'; tdNum.textContent = String(keyNum);

    const tdHex  = document.createElement('td'); tdHex.className = 'ks-hex';
    tdHex.title  = keyHex;
    tdHex.textContent = keyHex.slice(0,12) + '‚Ä¶' + keyHex.slice(-6);
    tdHex.onclick = () => navigator.clipboard.writeText(keyHex).then(() => showToast('‚úì Key hex copied'));

    const tdLeg  = document.createElement('td'); tdLeg.className = 'ks-addr';
    tdLeg.title  = legacyAddr;
    tdLeg.textContent = legacyAddr !== '‚Äî' ? legacyAddr.slice(0,8) + '‚Ä¶' + legacyAddr.slice(-4) : '‚Äî';
    if (legacyAddr !== '‚Äî') tdLeg.onclick = () => navigator.clipboard.writeText(legacyAddr).then(() => showToast('‚úì Address copied'));

    const tdNat  = document.createElement('td'); tdNat.className = 'ks-addr';
    tdNat.title  = nativeAddr;
    tdNat.textContent = nativeAddr !== '‚Äî' ? nativeAddr.slice(0,10) + '‚Ä¶' + nativeAddr.slice(-4) : '‚Äî';
    if (nativeAddr !== '‚Äî') tdNat.onclick = () => navigator.clipboard.writeText(nativeAddr).then(() => showToast('‚úì Address copied'));

    const tdBtn  = document.createElement('td');
    const chkBtn = document.createElement('button');
    chkBtn.className = 'btn btn-secondary';
    chkBtn.style.cssText = 'padding:4px 9px;font-size:10px';
    chkBtn.textContent = 'Check';
    const capturedHex = keyHex;
    chkBtn.onclick = () => checkKeyHex(capturedHex, chkBtn);
    tdBtn.appendChild(chkBtn);

    tr.append(tdNum, tdHex, tdLeg, tdNat, tdBtn);
    tbody.appendChild(tr);
  }
}

function ksGoPage(pageStr) {
  try {
    const cleaned = String(pageStr).replace(/[^0-9]/g, '') || '1';
    renderKeyspacePage(BigInt(cleaned));
  } catch(_) {}
}

function ksPrev() { renderKeyspacePage(ksPage > 1n ? ksPage - 1n : 1n); }
function ksNext() { renderKeyspacePage(ksPage + 1n); }

function ksRandom() {
  const rand = crypto.getRandomValues(new Uint8Array(16));
  let n = 0n;
  for (const b of rand) n = (n << 8n) | BigInt(b);
  // Keep within a reasonable range (not near the edge of keyspace)
  const MAX_REASONABLE = 2n ** 128n;
  renderKeyspacePage((n % MAX_REASONABLE) + 1n);
}

async function checkKeyHex(hexKey, btn) {
  if (btn) { btn.disabled = true; btn.textContent = '‚Ä¶'; }
  try {
    const privBytes = hexToBytes(hexKey);
    const pubC  = secp256k1.getPublicKey(privBytes, true);
    const addrs = [pubToLegacy(pubC), pubToNative(pubC), pubToP2SH(pubC)];
    const bals  = await checkBalances(addrs);
    stats.addrs += addrs.length;
    updateStats();

    let found = false;
    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        found = true;
        showResult('key#' + hexKey.slice(0,8), addr, info.balance, info.txCount, {
          privHex: hexKey, wif: toWIF(privBytes, true), wifU: toWIF(privBytes, false),
          addrs: { legacyC: pubToLegacy(pubC), native: pubToNative(pubC), p2sh: pubToP2SH(pubC) },
        });
        showToast('üèÜ Found balance!', 5000);
        if (btn) { btn.textContent = 'üèÜ'; btn.style.color = 'var(--success)'; }
      }
    }
    if (!found) {
      const anyUsed = Object.values(bals).some(i => i.txCount > 0);
      showToast(anyUsed ? 'üëÅ Used address (swept)' : '‚úÖ Empty');
      if (btn) { btn.textContent = anyUsed ? 'üëÅ' : '‚úÖ'; }
    }
  } catch(e) {
    showToast('Error: ' + e.message.slice(0,50));
    if (btn) { btn.textContent = '‚ùå'; }
  }
  if (btn) { btn.disabled = false; }
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ
updateStats();
initFromUrlParams();
initGraveyard();
</script>
</body>
</html>
