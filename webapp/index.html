<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BTC Seed Recovery Checker</title>
  <!-- Telegram WebApp SDK â€” enables in-app theming and close button -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #080812;
      --surface: #0f0f1c;
      --surface2: #161626;
      --surface3: #1e1e32;
      --border: #2a2a45;
      --text: #e2e8f0;
      --text2: #8892a4;
      --text3: #3a4158;
      --accent: #f7931a;
      --accent-dim: rgba(247, 147, 26, 0.12);
      --accent-glow: 0 0 20px rgba(247, 147, 26, 0.3);
      --success: #10b981;
      --success-dim: rgba(16, 185, 129, 0.12);
      --danger: #ef4444;
      --warning: #f59e0b;
      --r: 12px;
      --rs: 8px;
    }

    /* Telegram WebApp theme overrides â€” active when opened inside Telegram */
    .tg-theme {
      --bg:       var(--tg-theme-bg-color, #080812);
      --surface:  var(--tg-theme-secondary-bg-color, #0f0f1c);
      --text:     var(--tg-theme-text-color, #e2e8f0);
      --text2:    var(--tg-theme-hint-color, #8892a4);
      --accent:   var(--tg-theme-button-color, #f7931a);
    }

    /* Tab navigation */
    .tabs {
      display: flex;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; z-index: 9;
    }
    .tab {
      flex: 1; padding: 12px 8px;
      font-size: 13px; font-weight: 600;
      text-align: center; cursor: pointer;
      border: none; background: transparent;
      color: var(--text2);
      border-bottom: 2px solid transparent;
      transition: all .2s;
    }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }

    /* Batch textarea */
    .textarea {
      width: 100%;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      padding: 11px 14px;
      color: var(--text);
      font-size: 14px; line-height: 1.6;
      outline: none; resize: vertical;
      min-height: 120px;
      font-family: inherit;
      transition: border-color .2s, box-shadow .2s;
    }
    .textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
    .textarea::placeholder { color: var(--text3); }

    html { scroll-behavior: smooth; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
    }

    /* â”€â”€â”€ HEADER â”€â”€â”€ */
    .header {
      background: linear-gradient(180deg, #0d0d22 0%, var(--bg) 100%);
      border-bottom: 1px solid var(--border);
      padding: 18px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .header-brand { display: flex; align-items: center; gap: 12px; }
    .header-logo {
      font-size: 30px;
      filter: drop-shadow(0 0 10px rgba(247, 147, 26, 0.7));
    }
    .header-title { font-size: 19px; font-weight: 700; }
    .header-sub { font-size: 12px; color: var(--text2); }
    .header-right { display: flex; align-items: center; gap: 10px; }
    .badge {
      display: inline-flex; align-items: center; gap: 5px;
      padding: 4px 12px;
      border-radius: 100px;
      font-size: 12px; font-weight: 600;
    }
    .badge-idle { background: var(--surface2); color: var(--text2); border: 1px solid var(--border); }
    .badge-run  { background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(247,147,26,.4); }
    .pulse { display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: var(--accent); animation: blink 1s ease-in-out infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }

    /* â”€â”€â”€ STATS BAR â”€â”€â”€ */
    .stats-bar {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1px;
      background: var(--border);
      border-bottom: 1px solid var(--border);
    }
    .stat { background: var(--surface); padding: 14px 16px; text-align: center; }
    .stat-val { font-size: 22px; font-weight: 700; font-variant-numeric: tabular-nums; color: var(--accent); }
    .stat-lbl { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: .5px; }

    /* â”€â”€â”€ LAYOUT â”€â”€â”€ */
    .container {
      max-width: 860px;
      margin: 0 auto;
      padding: 24px 16px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--r);
      padding: 22px;
    }
    .card-title {
      font-size: 15px; font-weight: 600;
      margin-bottom: 16px;
      display: flex; align-items: center; gap: 8px;
    }
    .hidden { display: none !important; }

    /* â”€â”€â”€ INPUTS â”€â”€â”€ */
    .input-row { display: flex; gap: 10px; margin-bottom: 14px; }
    .input-field {
      flex: 1;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      padding: 11px 14px;
      color: var(--text);
      font-size: 15px;
      outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .input-field:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim);
    }
    .input-field::placeholder { color: var(--text3); }

    .options-row { display: flex; gap: 20px; margin-bottom: 14px; flex-wrap: wrap; }
    .opt-group { display: flex; flex-direction: column; gap: 5px; }
    .opt-lbl { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: .5px; }
    .toggle-row {
      display: flex;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      overflow: hidden;
    }
    .tbtn {
      padding: 7px 15px;
      font-size: 13px;
      border: none; background: transparent;
      color: var(--text2);
      cursor: pointer;
      transition: all .2s;
      white-space: nowrap;
    }
    .tbtn.active { background: var(--accent); color: #000; font-weight: 600; }

    /* â”€â”€â”€ BUTTONS â”€â”€â”€ */
    .btn {
      padding: 10px 20px;
      border-radius: var(--rs);
      border: none; cursor: pointer;
      font-size: 14px; font-weight: 600;
      transition: all .2s;
      display: inline-flex; align-items: center; gap: 7px;
    }
    .btn-primary { background: var(--accent); color: #000; }
    .btn-primary:hover { background: #e08618; box-shadow: var(--accent-glow); transform: translateY(-1px); }
    .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
    .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
    .btn-danger { background: var(--danger); color: #fff; }
    .btn-danger:hover { background: #dc2626; }
    .btn:disabled { opacity: .4; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
    .btn-row { display: flex; gap: 8px; flex-wrap: wrap; }

    /* â”€â”€â”€ PROGRESS â”€â”€â”€ */
    .prog-wrap { height: 3px; background: var(--border); border-radius: 3px; margin: 12px 0; overflow: hidden; }
    .prog-bar { height: 100%; background: var(--accent); border-radius: 3px; transition: width .3s; width: 0; }
    .prog-bar.ind { animation: ind 1.5s ease-in-out infinite; width: 30%; }
    @keyframes ind { 0%{transform:translateX(-200%)} 100%{transform:translateX(500%)} }

    /* â”€â”€â”€ FEED â”€â”€â”€ */
    .feed {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      height: 280px;
      overflow-y: auto;
      padding: 10px;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      font-size: 12.5px;
      scroll-behavior: smooth;
    }
    .feed-entry {
      padding: 3px 7px;
      border-radius: 4px;
      margin-bottom: 2px;
      display: flex; align-items: baseline; gap: 7px;
    }
    .fe-ts { color: var(--text3); font-size: 10.5px; min-width: 48px; flex-shrink: 0; }
    .fe-info    { color: var(--text2); }
    .fe-checking{ color: var(--text); }
    .fe-empty   { color: var(--text3); }
    .fe-used    { color: var(--warning); }
    .fe-found   { background: var(--success-dim); color: var(--success); font-weight: 600; border: 1px solid rgba(16,185,129,.25); }
    .fe-error   { color: var(--danger); }
    .fe-jackpot {
      background: linear-gradient(90deg, rgba(247,147,26,.18), rgba(255,100,0,.18));
      color: var(--accent); font-weight: 700;
      border: 1px solid rgba(247,147,26,.4);
      animation: jackpot 1s ease-in-out infinite;
    }
    @keyframes jackpot { 0%,100%{opacity:1} 50%{opacity:.65} }

    /* â”€â”€â”€ RESULTS â”€â”€â”€ */
    .result-item {
      background: var(--surface2);
      border: 1px solid var(--success);
      border-radius: var(--rs);
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
    }
    .result-bal { font-size: 22px; font-weight: 700; color: var(--success); margin-bottom: 10px; }
    .result-field {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 5px; font-size: 13px;
    }
    .rf-lbl { color: var(--text2); min-width: 68px; flex-shrink: 0; }
    .rf-val { color: var(--text); font-family: monospace; font-size: 12px; word-break: break-all; flex: 1; }
    .copy-btn {
      padding: 3px 8px; font-size: 11px;
      background: var(--surface3); border: 1px solid var(--border);
      border-radius: 4px; color: var(--text2);
      cursor: pointer; transition: all .2s; white-space: nowrap; flex-shrink: 0;
    }
    .copy-btn:hover { border-color: var(--accent); color: var(--accent); }
    .expl-link { font-size: 11px; color: var(--accent); text-decoration: none; flex-shrink: 0; }
    .expl-link:hover { text-decoration: underline; }

    /* â”€â”€â”€ HUNT â”€â”€â”€ */
    .hunt-desc { color: var(--text2); font-size: 13.5px; margin-bottom: 14px; line-height: 1.7; }
    .odds-pill {
      display: inline-block;
      background: var(--accent-dim);
      border: 1px solid rgba(247,147,26,.25);
      border-radius: var(--rs);
      padding: 7px 14px;
      font-size: 13px; color: var(--accent);
      margin-bottom: 16px;
    }

    /* â”€â”€â”€ WARNING BOX â”€â”€â”€ */
    .warn-box {
      background: rgba(245,158,11,.08);
      border: 1px solid rgba(245,158,11,.25);
      border-radius: var(--rs);
      padding: 10px 14px;
      font-size: 12.5px; color: var(--warning);
      margin-bottom: 14px;
    }

    /* â”€â”€â”€ HINT â”€â”€â”€ */
    .hint { font-size: 12px; color: var(--text2); margin-bottom: 14px; }

    /* â”€â”€â”€ TOAST â”€â”€â”€ */
    .toast {
      position: fixed; bottom: 24px; right: 24px;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--rs);
      padding: 11px 18px; font-size: 14px;
      z-index: 1000;
      transform: translateY(80px); opacity: 0;
      transition: all .25s;
      pointer-events: none;
    }
    .toast.show { transform: translateY(0); opacity: 1; }

    /* â”€â”€â”€ MEMORY GUIDE â”€â”€â”€ */
    .step-dots { display: flex; gap: 6px; margin-bottom: 18px; }
    .step-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); transition: background .2s; }
    .step-dot.active { background: var(--accent); }
    .step-dot.done   { background: var(--success); }
    .mem-step-title { font-size: 12px; color: var(--text2); margin-bottom: 10px; text-transform: uppercase; letter-spacing: .5px; }
    .mem-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .mem-btn { padding: 8px 14px; border-radius: var(--rs); border: 1px solid var(--border); background: var(--surface2); color: var(--text2); cursor: pointer; font-size: 13px; transition: all .2s; }
    .mem-btn:hover  { border-color: var(--accent); color: var(--accent); }
    .mem-btn.active { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); font-weight: 600; }
    .mem-word-cloud { display: flex; flex-wrap: wrap; gap: 6px; max-height: 140px; overflow-y: auto; background: var(--surface2); border: 1px solid var(--border); border-radius: var(--rs); padding: 10px; }
    .mem-word-tag { padding: 3px 9px; background: var(--surface3); border: 1px solid var(--border); border-radius: 20px; font-size: 12px; color: var(--text2); }

    /* â”€â”€â”€ FEELING LUCKY â”€â”€â”€ */
    .lucky-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 8px; margin: 12px 0; }
    .lucky-word { padding: 8px 12px; background: var(--surface2); border: 1px solid var(--border); border-radius: var(--rs); font-size: 13px; color: var(--text2); text-align: center; animation: fadeIn .3s ease; }
    .lucky-word.checking { border-color: var(--accent); color: var(--accent); }
    .lucky-word.empty    { opacity: .4; }
    .lucky-word.used     { border-color: var(--warning); color: var(--warning); }
    .lucky-word.found    { background: var(--success-dim); border-color: var(--success); color: var(--success); font-weight: 700; }
    @keyframes fadeIn { from{opacity:0;transform:translateY(4px)} to{opacity:1;transform:none} }

    /* â”€â”€â”€ AI SUGGEST â”€â”€â”€ */
    .api-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: flex-start; }
    .api-key-input { flex: 1; font-family: monospace; font-size: 13px; }
    .provider-badge { font-size: 11px; color: var(--text2); padding: 4px 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; white-space: nowrap; flex-shrink: 0; margin-top: 10px; }
    .ai-word-cloud { display: flex; flex-wrap: wrap; gap: 6px; max-height: 160px; overflow-y: auto; background: var(--surface2); border: 1px solid var(--border); border-radius: var(--rs); padding: 10px; }
    .ai-word-tag { padding: 3px 9px; background: var(--accent-dim); border: 1px solid rgba(247,147,26,.3); border-radius: 20px; font-size: 12px; color: var(--accent); }

    /* â”€â”€â”€ RESPONSIVE â”€â”€â”€ */
    @media (max-width: 580px) {
      .stats-bar { grid-template-columns: repeat(2, 1fr); }
      .header { flex-direction: column; gap: 10px; align-items: flex-start; }
      .input-row { flex-direction: column; }
    }
  </style>
</head>
<body>

<header class="header">
  <div class="header-brand">
    <span class="header-logo">â‚¿</span>
    <div>
      <div class="header-title">BTC Seed Recovery Checker</div>
      <div class="header-sub">Brain wallet &amp; BIP39 balance checker â€” runs entirely in your browser</div>
    </div>
  </div>
  <div class="header-right">
    <span class="badge badge-idle" id="statusBadge">â¸ Idle</span>
  </div>
</header>

<div class="stats-bar">
  <div class="stat">
    <div class="stat-val" id="sWords">0</div>
    <div class="stat-lbl">Words Checked</div>
  </div>
  <div class="stat">
    <div class="stat-val" id="sVars">0</div>
    <div class="stat-lbl">Variations Tried</div>
  </div>
  <div class="stat">
    <div class="stat-val" id="sAddrs">0</div>
    <div class="stat-lbl">Addresses Queried</div>
  </div>
  <div class="stat" style="--accent:var(--success)">
    <div class="stat-val" id="sFound" style="color:var(--success)">0</div>
    <div class="stat-lbl">Wallets Found</div>
  </div>
</div>

<!-- â”€â”€â”€ TABS â”€â”€â”€ -->
<nav class="tabs" id="tabBar">
  <button class="tab active" onclick="switchTab('single')" style="font-size:12px">ğŸ” Single</button>
  <button class="tab" onclick="switchTab('batch')"  style="font-size:12px">ğŸ“‹ Batch</button>
  <button class="tab" onclick="switchTab('hunt')"   style="font-size:12px">ğŸ° Hunt</button>
  <button class="tab" onclick="switchTab('memory')" style="font-size:12px">ğŸ§  Memory</button>
  <button class="tab" onclick="switchTab('ai')"     style="font-size:12px">ğŸ¤– AI</button>
</nav>

<div class="container">

  <!-- â”€â”€â”€ SINGLE CHECK PANEL â”€â”€â”€ -->
  <div class="tab-panel" id="panelSingle">
  <div class="card">
    <div class="card-title">ğŸ” Check a Word or Phrase</div>

    <div class="warn-box">
      âš ï¸ This tool checks Bitcoin addresses derived from your passphrase for existing balances.
      All computation happens locally in your browser â€” nothing is sent to any server.
    </div>

    <div class="input-row">
      <input id="wordInput" type="text" class="input-field"
        placeholder="Enter word, phrase or passphraseâ€¦"
        autocomplete="off" autocorrect="off" spellcheck="false">
    </div>

    <div class="options-row">
      <div class="opt-group">
        <div class="opt-lbl">Derivation Mode</div>
        <div class="toggle-row">
          <button class="tbtn active" id="modeBW" onclick="setMode('brainwallet')">Brain Wallet</button>
          <button class="tbtn" id="modeBIP" onclick="setMode('bip39')">BIP39 Seed</button>
        </div>
      </div>
      <div class="opt-group">
        <div class="opt-lbl">Search Depth</div>
        <div class="toggle-row">
          <button class="tbtn active" id="depthN" onclick="setDepth('normal')">Normal</button>
          <button class="tbtn" id="depthD" onclick="setDepth('deep')">Deep</button>
        </div>
      </div>
    </div>

    <div class="hint" id="modeHint">
      Brain wallet: SHA256(passphrase) â†’ private key Â· checks Legacy, SegWit &amp; Native SegWit addresses
    </div>

    <div class="btn-row">
      <button class="btn btn-primary" id="btnCheck" onclick="startCheck()">ğŸ” Check Word</button>
      <button class="btn btn-danger hidden" id="btnStop" onclick="stopCheck()">â¹ Stop</button>
    </div>

    <div class="prog-wrap hidden" id="progWrap">
      <div class="prog-bar" id="progBar"></div>
    </div>
  </div>

  <!-- â”€â”€â”€ LIVE FEED â”€â”€â”€ -->
  <div class="card hidden" id="feedCard">
    <div class="card-title" style="justify-content:space-between">
      <span>ğŸ“¡ Live Feed</span>
      <button onclick="clearFeed()" style="background:none;border:none;color:var(--text3);cursor:pointer;font-size:12px;">Clear</button>
    </div>
    <div class="feed" id="feed"></div>
  </div>

  <!-- â”€â”€â”€ RESULTS (shared across tabs) â”€â”€â”€ -->
  <div class="card hidden" id="resultsCard">
    <div class="card-title">
      ğŸ† Found Wallets
      <span class="badge badge-run" id="foundBadge">0</span>
    </div>
    <div id="resultsList"></div>
  </div>

  </div><!-- /panelSingle -->


  <!-- â”€â”€â”€ BATCH CHECK PANEL â”€â”€â”€ -->
  <div class="tab-panel hidden" id="panelBatch">

    <div class="card">
      <div class="card-title">ğŸ“‹ Batch Check</div>
      <div class="warn-box">
        Paste a list of words/phrases â€” one per line. Each will be checked with all variations.
        Runs entirely in your browser using your IP address.
      </div>

      <div style="margin-bottom:14px">
        <textarea id="batchInput" class="textarea"
          placeholder="Enter words, one per line:&#10;satoshi&#10;nakamoto&#10;bitcoin&#10;password123&#10;..."></textarea>
      </div>

      <div class="options-row">
        <div class="opt-group">
          <div class="opt-lbl">Derivation Mode</div>
          <div class="toggle-row">
            <button class="tbtn active" id="batchModeBW"  onclick="setBatchMode('brainwallet')">Brain Wallet</button>
            <button class="tbtn"        id="batchModeBIP" onclick="setBatchMode('bip39')">BIP39 Seed</button>
          </div>
        </div>
        <div class="opt-group">
          <div class="opt-lbl">Search Depth</div>
          <div class="toggle-row">
            <button class="tbtn active" id="batchDepthN" onclick="setBatchDepth('normal')">Normal</button>
            <button class="tbtn"        id="batchDepthD" onclick="setBatchDepth('deep')">Deep</button>
          </div>
        </div>
      </div>

      <div class="btn-row">
        <button class="btn btn-primary" id="btnBatchCheck" onclick="startBatch()">ğŸ” Check All Words</button>
        <button class="btn btn-danger hidden" id="btnBatchStop" onclick="stopBatch()">â¹ Stop</button>
      </div>

      <div class="prog-wrap hidden" id="batchProgWrap">
        <div class="prog-bar" id="batchProgBar"></div>
      </div>
    </div>

    <div class="card hidden" id="batchFeedCard">
      <div class="card-title" style="justify-content:space-between">
        <span>ğŸ“¡ Batch Feed</span>
        <span id="batchProgress" style="font-size:12px;color:var(--text2)"></span>
      </div>
      <div class="feed" id="batchFeed"></div>
    </div>

  </div><!-- /panelBatch -->

  <!-- â”€â”€â”€ RANDOM KEY HUNT PANEL â”€â”€â”€ -->
  <div class="tab-panel hidden" id="panelHunt">

    <div class="card">
      <div class="card-title">ğŸ° Random Key Hunt</div>
      <p class="hunt-desc">
        Randomly generate Bitcoin private keys and check their balances.
        Each key has a 1 in 2<sup>256</sup> chance of holding funds â€” but someone has to find it!
        Uses your browser's cryptographically secure RNG (<code>crypto.getRandomValues</code>).
      </p>
      <div class="odds-pill">
        ğŸ² Probability per key: ~1 in 115 quattuorvigintillion â€” pure lottery odds
      </div>

      <div class="btn-row" style="margin-bottom:14px">
        <button class="btn btn-secondary" id="bH10"   onclick="startHunt(10)">Hunt 10</button>
        <button class="btn btn-secondary" id="bH100"  onclick="startHunt(100)">Hunt 100</button>
        <button class="btn btn-secondary" id="bH1000" onclick="startHunt(1000)">Hunt 1 000</button>
        <button class="btn btn-danger hidden" id="bHStop" onclick="stopHunt()">â¹ Stop</button>
      </div>

      <div class="feed" id="huntFeed" style="height:240px"></div>
    </div>

  </div><!-- /panelHunt -->


  <!-- â”€â”€â”€ MEMORY GUIDE PANEL â”€â”€â”€ -->
  <div class="tab-panel hidden" id="panelMemory">

    <div class="card">
      <div class="card-title">ğŸ§  Memory Guide</div>
      <p class="hint">Answer a few questions to build a personalized word list based on your memories of the wallet.</p>

      <!-- Wizard progress dots -->
      <div class="step-dots">
        <div class="step-dot active"></div>
        <div class="step-dot"></div>
        <div class="step-dot"></div>
        <div class="step-dot"></div>
      </div>

      <!-- Step 0: Year -->
      <div id="memStep0">
        <div class="mem-step-title">When did you create this wallet?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="year" data-val="2009" onclick="memAnswer('year','2009')">2009</button>
          <button class="mem-btn" data-mem="year" data-val="2010" onclick="memAnswer('year','2010')">2010</button>
          <button class="mem-btn" data-mem="year" data-val="2011" onclick="memAnswer('year','2011')">2011</button>
          <button class="mem-btn" data-mem="year" data-val="2012" onclick="memAnswer('year','2012')">2012</button>
          <button class="mem-btn" data-mem="year" data-val="2013" onclick="memAnswer('year','2013')">2013</button>
          <button class="mem-btn" data-mem="year" data-val="2014" onclick="memAnswer('year','2014')">2014</button>
          <button class="mem-btn" data-mem="year" data-val="2015" onclick="memAnswer('year','2015')">2015</button>
          <button class="mem-btn" data-mem="year" data-val="2016" onclick="memAnswer('year','2016')">2016</button>
          <button class="mem-btn" data-mem="year" data-val="2017" onclick="memAnswer('year','2017')">2017</button>
          <button class="mem-btn" data-mem="year" data-val="2018" onclick="memAnswer('year','2018')">2018</button>
          <button class="mem-btn" data-mem="year" data-val="2019" onclick="memAnswer('year','2019')">2019</button>
          <button class="mem-btn" data-mem="year" data-val="2020" onclick="memAnswer('year','2020')">2020</button>
          <button class="mem-btn" data-mem="year" data-val="2021" onclick="memAnswer('year','2021')">2021</button>
          <button class="mem-btn" data-mem="year" data-val="not_sure" onclick="memAnswer('year','not_sure')">Not sure</button>
        </div>
      </div>

      <!-- Step 1: Topic -->
      <div id="memStep1" class="hidden">
        <div class="mem-step-title">What were your main interests at the time?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="topic" data-val="gaming"   onclick="memAnswer('topic','gaming')">ğŸ® Gaming</button>
          <button class="mem-btn" data-mem="topic" data-val="movies"   onclick="memAnswer('topic','movies')">ğŸ¬ Movies</button>
          <button class="mem-btn" data-mem="topic" data-val="sports"   onclick="memAnswer('topic','sports')">âš½ Sports</button>
          <button class="mem-btn" data-mem="topic" data-val="music"    onclick="memAnswer('topic','music')">ğŸµ Music</button>
          <button class="mem-btn" data-mem="topic" data-val="crypto"   onclick="memAnswer('topic','crypto')">â‚¿ Crypto</button>
          <button class="mem-btn" data-mem="topic" data-val="nature"   onclick="memAnswer('topic','nature')">ğŸ‰ Nature/Fantasy</button>
          <button class="mem-btn" data-mem="topic" data-val="personal" onclick="memAnswer('topic','personal')">â¤ï¸ Personal</button>
          <button class="mem-btn" data-mem="topic" data-val="work"     onclick="memAnswer('topic','work')">ğŸ’¼ Work/Tech</button>
        </div>
      </div>

      <!-- Step 2: Platform -->
      <div id="memStep2" class="hidden">
        <div class="mem-step-title">What device or platform were you using?</div>
        <div class="mem-grid">
          <button class="mem-btn" data-mem="platform" data-val="windows" onclick="memAnswer('platform','windows')">ğŸ–¥ Windows PC</button>
          <button class="mem-btn" data-mem="platform" data-val="mac"     onclick="memAnswer('platform','mac')">ğŸ Mac</button>
          <button class="mem-btn" data-mem="platform" data-val="mobile"  onclick="memAnswer('platform','mobile')">ğŸ“± Mobile</button>
          <button class="mem-btn" data-mem="platform" data-val="linux"   onclick="memAnswer('platform','linux')">ğŸ§ Linux</button>
          <button class="mem-btn" data-mem="platform" data-val="web"     onclick="memAnswer('platform','web')">ğŸŒ Web/Online</button>
          <button class="mem-btn" data-mem="platform" data-val="any"     onclick="memAnswer('platform','any')">ğŸ¤· Not Sure</button>
        </div>
      </div>

      <!-- Step 3: Hint words -->
      <div id="memStep3" class="hidden">
        <div class="mem-step-title">Any words you remember? (optional â€” separate with spaces)</div>
        <div class="input-row" style="margin-bottom:12px">
          <input id="memHintInput" type="text" class="input-field"
            placeholder="e.g. dragon fire 2013 lucky"
            oninput="memAnswers.hint = this.value">
        </div>
        <div class="btn-row">
          <button class="btn btn-primary" onclick="updateMemWordCloud()">ğŸ§  Generate Word List</button>
          <button class="btn btn-secondary" onclick="resetMemWizard()">â†º Start Over</button>
        </div>
      </div>
    </div>

    <!-- Generated word list -->
    <div class="card hidden" id="memResultsSection">
      <div class="card-title" style="justify-content:space-between">
        <span>ğŸ“ Generated Words</span>
        <span id="memWordCount" style="font-size:12px;color:var(--text2)">0 words</span>
      </div>
      <div class="mem-word-cloud" id="memWordCloud"></div>
      <div class="btn-row" style="margin-top:14px">
        <button class="btn btn-primary" onclick="sendMemToBatch()">ğŸ“‹ Send to Batch Check</button>
        <button class="btn btn-secondary" onclick="feelingLucky()">ğŸ€ Try My Luck</button>
      </div>
    </div>

    <!-- Feeling Lucky -->
    <div class="card" id="luckySection">
      <div class="card-title">ğŸ€ Feeling Lucky</div>
      <p class="hint" style="margin-bottom:12px">
        Instantly check the most common brain wallet passphrases â€” one click, no setup needed.
        Your generated words are included if available.
      </p>
      <div class="btn-row" style="margin-bottom:12px">
        <button class="btn btn-primary" id="btnLucky" onclick="feelingLucky()">ğŸ€ Try My Luck</button>
      </div>
      <div class="lucky-grid" id="luckyGrid"></div>
    </div>

  </div><!-- /panelMemory -->


  <!-- â”€â”€â”€ AI SUGGEST PANEL â”€â”€â”€ -->
  <div class="tab-panel hidden" id="panelAi">

    <div class="card">
      <div class="card-title">ğŸ¤– AI Word Suggest</div>
      <p class="hint">Let AI generate personalized passphrase candidates based on your context.</p>

      <div class="warn-box">
        ğŸ”‘ Your API key is sent directly to the AI provider from your browser â€” never to our servers.
        <strong>Groq is free</strong> â€” get a key at
        <a href="https://console.groq.com" target="_blank" rel="noopener" style="color:var(--accent)">console.groq.com</a>
      </div>

      <div class="api-row">
        <input id="aiApiKey" type="password" class="input-field api-key-input"
          placeholder="Groq key (gsk_â€¦) or OpenAI key (sk-â€¦)"
          oninput="detectAIProvider(this.value)">
        <span class="provider-badge" id="aiProviderBadge">Auto-detect</span>
      </div>

      <div style="margin-bottom:14px">
        <div class="opt-lbl" style="margin-bottom:6px">Your context (describe the wallet, your interests, or any hints)</div>
        <textarea id="aiContext" class="textarea" style="min-height:80px"
          placeholder="e.g. I was into gaming in 2013, used Windows, my favorite game was Minecraft and my dog's name was Maxâ€¦"></textarea>
      </div>

      <div class="btn-row">
        <button class="btn btn-primary" id="btnAIGenerate" onclick="generateAIWords()">ğŸ¤– Generate Words</button>
      </div>
    </div>

    <!-- AI Results -->
    <div class="card hidden" id="aiResultsSection">
      <div class="card-title" style="justify-content:space-between">
        <span>âœ¨ AI Suggestions</span>
        <span id="aiWordCount" style="font-size:12px;color:var(--text2)">0 words</span>
      </div>
      <div class="ai-word-cloud" id="aiWordCloud"></div>
      <div class="btn-row" style="margin-top:14px">
        <button class="btn btn-primary" onclick="sendAIToBatch()">ğŸ“‹ Send to Batch Check</button>
        <button class="btn btn-secondary" onclick="feelingLucky()">ğŸ€ Feeling Lucky</button>
      </div>
    </div>

  </div><!-- /panelAi -->


</div><!-- /container -->

<div class="toast" id="toast"></div>

<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IMPORTS â€” noble crypto libraries via esm.sh CDN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { sha256   } from 'https://esm.sh/@noble/hashes@1.7.2/sha256';
import { ripemd160} from 'https://esm.sh/@noble/hashes@1.7.2/ripemd160';
import { hmac     } from 'https://esm.sh/@noble/hashes@1.7.2/hmac';
import { sha512   } from 'https://esm.sh/@noble/hashes@1.7.2/sha512';
import { secp256k1} from 'https://esm.sh/@noble/curves@1.8.1/secp256k1';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TELEGRAM WEBAPP INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const tg = window.Telegram?.WebApp;
if (tg) {
  tg.ready();
  tg.expand(); // full-screen in Telegram
  // Apply Telegram theme to root element
  if (tg.colorScheme === 'light') {
    // light mode: keep our dark theme but signal awareness
    document.documentElement.style.setProperty('--bg', '#ffffff');
    document.documentElement.style.setProperty('--surface', '#f0f0f5');
    document.documentElement.style.setProperty('--surface2', '#e8e8ef');
    document.documentElement.style.setProperty('--text', '#000000');
    document.documentElement.style.setProperty('--text2', '#555555');
    document.documentElement.style.setProperty('--border', '#d0d0d8');
    document.documentElement.style.setProperty('--text3', '#999999');
    document.documentElement.style.setProperty('--surface3', '#dcdce4');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let mode  = 'brainwallet';
let depth = 'normal';
let batchMode  = 'brainwallet';
let batchDepth = 'normal';
let isChecking = false;
let isHunting  = false;
let isBatching = false;
let stopCheck  = false;
let stopHunt   = false;
let stopBatchFlag = false;

const stats = { words: 0, vars: 0, addrs: 0, found: 0, keys: 0 };

// Expose UI handlers to inline onclick attributes
window.setMode          = setMode;
window.setDepth         = setDepth;
window.setBatchMode     = setBatchMode;
window.setBatchDepth    = setBatchDepth;
window.startCheck       = startCheck;
window.stopCheck        = () => { stopCheck = true; byId('btnStop').textContent = 'â³ Stoppingâ€¦'; };
window.startHunt        = startHunt;
window.stopHunt         = () => { stopHunt = true; byId('bHStop').textContent = 'â³ Stoppingâ€¦'; };
window.startBatch       = startBatch;
window.stopBatch        = () => { stopBatchFlag = true; byId('btnBatchStop').textContent = 'â³ Stoppingâ€¦'; };
window.clearFeed        = () => { byId('feed').innerHTML = ''; };
window.switchTab        = switchTab;
window.memAnswer        = memAnswer;
window.showMemStep      = showMemStep;
window.updateMemWordCloud = updateMemWordCloud;
window.sendMemToBatch   = sendMemToBatch;
window.resetMemWizard   = resetMemWizard;
window.feelingLucky     = feelingLucky;
window.generateAIWords  = generateAIWords;
window.sendAIToBatch    = sendAIToBatch;
window.detectAIProvider = detectAIProvider;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TAB SWITCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function switchTab(name) {
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  byId('panel' + name.charAt(0).toUpperCase() + name.slice(1)).classList.remove('hidden');
  const tabs = { single: 0, batch: 1, hunt: 2, memory: 3, ai: 4 };
  document.querySelectorAll('.tab')[tabs[name]]?.classList.add('active');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const byId = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));

function bytesToHex(b) {
  return Array.from(b, x => x.toString(16).padStart(2, '0')).join('');
}
function hexToBytes(hex) {
  if (hex.length & 1) hex = '0' + hex;
  const b = new Uint8Array(hex.length >> 1);
  for (let i = 0; i < hex.length; i += 2) b[i >> 1] = parseInt(hex.slice(i, i + 2), 16);
  return b;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BITCOIN PRIMITIVES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

function base58Encode(bytes) {
  if (!bytes.length) return '';
  let n = BigInt('0x' + bytesToHex(bytes));
  let s = '';
  while (n > 0n) { const r = Number(n % 58n); s = B58[r] + s; n /= 58n; }
  for (const b of bytes) { if (b !== 0) break; s = '1' + s; }
  return s;
}

function base58Check(version, payload) {
  const full = new Uint8Array([version, ...payload]);
  const chk  = sha256(sha256(full)).slice(0, 4);
  return base58Encode(new Uint8Array([...full, ...chk]));
}

function hash160(pub) {
  return ripemd160(sha256(pub));
}

// P2PKH  â†’ 1...
function pubToLegacy(pub) {
  return base58Check(0x00, hash160(pub));
}

// P2SH-P2WPKH â†’ 3...
function pubToP2SH(pub) {
  const h   = hash160(pub);
  const rs  = new Uint8Array([0x00, 0x14, ...h]); // OP_0 PUSH20 <hash>
  return base58Check(0x05, hash160(rs));
}

// Bech32 (native segwit P2WPKH) â†’ bc1q...
const B32C = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const B32G = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

function b32Polymod(v) {
  let c = 1;
  for (const x of v) {
    const t = c >> 25;
    c = ((c & 0x1ffffff) << 5) ^ x;
    for (let i = 0; i < 5; i++) if ((t >> i) & 1) c ^= B32G[i];
  }
  return c;
}
function b32Hrp(hrp) {
  const r = [];
  for (let i = 0; i < hrp.length; i++) r.push(hrp.charCodeAt(i) >> 5);
  r.push(0);
  for (let i = 0; i < hrp.length; i++) r.push(hrp.charCodeAt(i) & 31);
  return r;
}
function b32Checksum(hrp, data) {
  const poly = b32Polymod([...b32Hrp(hrp), ...data, 0, 0, 0, 0, 0, 0]) ^ 1;
  return Array.from({ length: 6 }, (_, i) => (poly >> (5 * (5 - i))) & 31);
}
function convertBits(data, from, to, pad = true) {
  let acc = 0, bits = 0;
  const out = [], maxv = (1 << to) - 1;
  for (const v of data) {
    acc = (acc << from) | v; bits += from;
    while (bits >= to) { bits -= to; out.push((acc >> bits) & maxv); }
  }
  if (pad && bits > 0) out.push((acc << (to - bits)) & maxv);
  return out;
}
function pubToNative(pub) {
  const h    = hash160(pub);
  const data = [0, ...convertBits(Array.from(h), 8, 5)];
  return 'bc1' + [...data, ...b32Checksum('bc', data)].map(d => B32C[d]).join('');
}

function toWIF(privBytes, compressed = true) {
  const d   = new Uint8Array([0x80, ...privBytes, ...(compressed ? [0x01] : [])]);
  const chk = sha256(sha256(d)).slice(0, 4);
  return base58Encode(new Uint8Array([...d, ...chk]));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BRAIN WALLET  â€” SHA256(passphrase) â†’ addresses
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function deriveBrainWallet(passphrase) {
  const priv = sha256(new TextEncoder().encode(passphrase));
  const pubC = secp256k1.getPublicKey(priv, true);
  const pubU = secp256k1.getPublicKey(priv, false);
  return {
    privHex: bytesToHex(priv),
    wif:     toWIF(priv, true),
    wifU:    toWIF(priv, false),
    addrs: {
      legacyC:  pubToLegacy(pubC),
      legacyU:  pubToLegacy(pubU),
      p2sh:     pubToP2SH(pubC),
      native:   pubToNative(pubC),
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BIP39 + BIP32  â€” mnemonic â†’ m/44'/0'/0'/0/0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const N_SECP = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n;

function u32BE(n) {
  return [(n >>> 24) & 0xff, (n >>> 16) & 0xff, (n >>> 8) & 0xff, n & 0xff];
}

async function deriveBip39(mnemonic) {
  const enc  = new TextEncoder();
  const mn   = enc.encode(mnemonic.normalize('NFKD'));
  const salt = enc.encode('mnemonic');

  const km  = await crypto.subtle.importKey('raw', mn, { name: 'PBKDF2' }, false, ['deriveBits']);
  const buf = await crypto.subtle.deriveBits(
    { name: 'PBKDF2', salt, iterations: 2048, hash: 'SHA-512' }, km, 512
  );
  const seed = new Uint8Array(buf);

  // BIP32 master key
  const I0   = hmac(sha512, enc.encode('Bitcoin seed'), seed);
  let priv   = I0.slice(0, 32);
  let chain  = I0.slice(32);

  // m/44'/0'/0'/0/0
  for (const idx of [0x8000002c, 0x80000000, 0x80000000, 0, 0]) {
    const hard = idx >= 0x80000000;
    const data = hard
      ? new Uint8Array([0x00, ...priv, ...u32BE(idx)])
      : new Uint8Array([...secp256k1.getPublicKey(priv, true), ...u32BE(idx)]);
    const Ic  = hmac(sha512, chain, data);
    const IL  = Ic.slice(0, 32);
    chain     = Ic.slice(32);
    const child = (BigInt('0x' + bytesToHex(IL)) + BigInt('0x' + bytesToHex(priv))) % N_SECP;
    priv = hexToBytes(child.toString(16).padStart(64, '0'));
  }

  const pubC = secp256k1.getPublicKey(priv, true);
  return {
    privHex: bytesToHex(priv),
    wif:     toWIF(priv, true),
    addrs: {
      legacyC: pubToLegacy(pubC),
      native:  pubToNative(pubC),
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORD VARIATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateVariations(word, dep) {
  const w  = word.trim();
  const wl = w.toLowerCase();
  const wu = w.toUpperCase();
  const wc = wl[0].toUpperCase() + wl.slice(1);
  const leet = wl
    .replace(/a/g,'4').replace(/e/g,'3').replace(/i/g,'1')
    .replace(/o/g,'0').replace(/s/g,'5').replace(/t/g,'7');

  const out = new Set([w, wl, wu, wc]);
  if (leet !== wl) out.add(leet);

  // Suffixes
  for (const s of ['1','2','12','123','1234','12345','!','!!','123!','007','69','420']) {
    out.add(wl + s);
  }
  // Bitcoin era years
  for (const y of ['2009','2010','2011','2012','2013']) out.add(wl + y);

  // Prefixes
  for (const p of ['my', 'the', 'i']) out.add(p + wl);

  if (dep === 'deep') {
    // All years 2009â€“2023
    for (let y = 2009; y <= 2023; y++) { out.add(wl + y); out.add(y + wl); }
    // Double
    out.add(wl + wl);
    // Leet with suffixes
    for (const s of ['1','123','!','2009','2010','2011']) out.add(leet + s);
    // Capitalized leet
    out.add(leet[0].toUpperCase() + leet.slice(1));
    // Alternating caps
    out.add([...wl].map((c, i) => i % 2 === 0 ? c.toUpperCase() : c).join(''));
    // Space / separator variants
    if (w.includes(' ')) {
      out.add(w.replace(/\s+/g, ''));
      out.add(w.replace(/\s+/g, '_'));
      out.add(w.replace(/\s+/g, '.'));
      out.add(w.replace(/\s+/g, '-'));
      out.add(w.replace(/\s+/g, ''));
    }
    // Extra lucky numbers
    for (const n of ['777','666','88','99','2017','2018','2020','2021']) out.add(wl + n);
  }

  return [...out].filter(v => v.length > 0 && v.length <= 80);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BALANCE CHECKER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function checkBalances(addresses) {
  if (!addresses.length) return {};
  const res = {};

  // â”€â”€ blockchain.info multiaddr (batch, handles all address types) â”€â”€
  try {
    const url  = `https://blockchain.info/multiaddr?active=${addresses.join('|')}&n=0`;
    const resp = await fetch(url, { signal: AbortSignal.timeout(12000) });
    if (resp.ok) {
      const data = await resp.json();
      for (const a of (data.addresses || [])) {
        res[a.address] = { balance: a.final_balance / 1e8, txCount: a.n_tx };
      }
      for (const addr of addresses) {
        if (!res[addr]) res[addr] = { balance: 0, txCount: 0 };
      }
      return res;
    }
  } catch (_) { /* fall through to blockstream */ }

  // â”€â”€ blockstream.info fallback (individual queries) â”€â”€
  for (const addr of addresses) {
    if (res[addr]) continue;
    try {
      const resp = await fetch(
        `https://blockstream.info/api/address/${addr}`,
        { signal: AbortSignal.timeout(8000) }
      );
      if (resp.ok) {
        const d   = await resp.json();
        const bal = (d.chain_stats.funded_txo_sum - d.chain_stats.spent_txo_sum) / 1e8;
        res[addr] = { balance: bal, txCount: d.chain_stats.tx_count };
      } else {
        res[addr] = { balance: 0, txCount: 0 };
      }
    } catch (_) {
      res[addr] = { balance: 0, txCount: 0 };
    }
    await sleep(100);
  }

  return res;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStats() {
  byId('sWords').textContent = stats.words.toLocaleString();
  byId('sVars').textContent  = stats.vars.toLocaleString();
  byId('sAddrs').textContent = stats.addrs.toLocaleString();
  byId('sFound').textContent = stats.found;
}

function ts() {
  return new Date().toLocaleTimeString('en', { hour12: false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
}

function addFeed(msg, cls = 'fe-info') {
  const feed = byId('feed');
  byId('feedCard').classList.remove('hidden');
  const el  = document.createElement('div');
  el.className = `feed-entry ${cls}`;
  const tsEl = document.createElement('span');
  tsEl.className = 'fe-ts';
  tsEl.textContent = ts();
  el.appendChild(tsEl);
  el.appendChild(document.createTextNode(' ' + msg));
  feed.appendChild(el);
  feed.scrollTop = feed.scrollHeight;
  return el;
}

function updateLastFeed(msg, cls) {
  const feed = byId('feed');
  const last = feed.lastElementChild;
  if (!last) return;
  last.className = `feed-entry ${cls}`;
  const tsEl = last.querySelector('.fe-ts');
  last.textContent = '';
  if (tsEl) last.appendChild(tsEl);
  last.appendChild(document.createTextNode(' ' + msg));
}

function addHuntFeed(msg, cls = 'fe-info') {
  const feed = byId('huntFeed');
  const el   = document.createElement('div');
  el.className = `feed-entry ${cls}`;
  el.textContent = `${ts()} ${msg}`;
  feed.appendChild(el);
  while (feed.children.length > 200) feed.removeChild(feed.firstChild);
  feed.scrollTop = feed.scrollHeight;
}

function setProgress(pct) {
  const wrap = byId('progWrap');
  const bar  = byId('progBar');
  wrap.classList.remove('hidden');
  if (pct < 0) {
    bar.classList.add('ind');
  } else {
    bar.classList.remove('ind');
    bar.style.width = pct + '%';
  }
  if (pct >= 100) setTimeout(() => wrap.classList.add('hidden'), 600);
}

function showToast(msg, dur = 2800) {
  const t = byId('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), dur);
}

function showResult(label, addr, balance, txCount, keyInfo) {
  const card = byId('resultsCard');
  card.classList.remove('hidden');

  const btc  = typeof balance === 'number' ? balance.toFixed(8) : String(balance);
  const eurl = addr.startsWith('bc1')
    ? `https://blockstream.info/address/${addr}`
    : `https://www.blockchain.com/explorer/addresses/btc/${addr}`;

  const div  = document.createElement('div');
  div.className = 'result-item';

  // Balance
  const balDiv = document.createElement('div');
  balDiv.className = 'result-bal';
  balDiv.textContent = `${btc} BTC`;
  div.appendChild(balDiv);

  // Helper: row with label, value, copy btn, optional link
  const addRow = (lbl, val, link) => {
    const row  = document.createElement('div');
    row.className = 'result-field';

    const l = document.createElement('span'); l.className = 'rf-lbl'; l.textContent = lbl;
    const v = document.createElement('span'); v.className = 'rf-val'; v.textContent = val;
    const c = document.createElement('button'); c.className = 'copy-btn'; c.textContent = 'Copy';
    c.addEventListener('click', () => navigator.clipboard.writeText(val).then(() => showToast('âœ“ Copied!')));

    row.appendChild(l); row.appendChild(v); row.appendChild(c);
    if (link) {
      const a = document.createElement('a');
      a.className = 'expl-link'; a.href = link; a.target = '_blank'; a.rel = 'noopener';
      a.textContent = 'Explorer â†—';
      row.appendChild(a);
    }
    div.appendChild(row);
  };

  addRow('Passphrase', label);
  addRow('Address', addr, eurl);
  if (keyInfo.wif)     addRow('WIF (comp)', keyInfo.wif);
  if (keyInfo.wifU)    addRow('WIF (uncomp)', keyInfo.wifU);
  if (keyInfo.privHex) addRow('Priv Key', keyInfo.privHex);

  if (txCount > 0) {
    const info = document.createElement('div');
    info.style.cssText = 'font-size:12px;color:var(--text2);margin-top:8px';
    info.textContent = `${txCount} transaction(s) recorded on this address`;
    div.appendChild(info);
  }

  const warn = document.createElement('div');
  warn.style.cssText = 'font-size:11px;color:var(--danger);margin-top:8px';
  warn.textContent = 'âš ï¸ Save this key immediately â€” it is not stored anywhere';
  div.appendChild(warn);

  byId('resultsList').prepend(div);

  stats.found++;
  byId('foundBadge').textContent = stats.found;
  updateStats();

  card.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOGGLE CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setMode(m) {
  mode = m;
  byId('modeBW').classList.toggle('active',  m === 'brainwallet');
  byId('modeBIP').classList.toggle('active', m === 'bip39');
  byId('modeHint').textContent = m === 'brainwallet'
    ? "Brain wallet: SHA256(passphrase) â†’ private key Â· checks Legacy, P2SH-SegWit & Native SegWit addresses"
    : "BIP39 seed: PBKDF2(2048) + BIP32 m/44'/0'/0'/0/0 Â· slower, checks Legacy & Native SegWit";
}
function setDepth(d) {
  depth = d;
  byId('depthN').classList.toggle('active', d === 'normal');
  byId('depthD').classList.toggle('active', d === 'deep');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN CHECK FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startCheck() {
  const word = byId('wordInput').value.trim();
  if (!word)       { showToast('Enter a word or phrase first'); return; }
  if (isChecking)  return;

  isChecking = true;
  stopCheck  = false;

  byId('btnCheck').classList.add('hidden');
  byId('btnStop').classList.remove('hidden');
  byId('btnStop').textContent = 'â¹ Stop';
  byId('statusBadge').innerHTML = '<span class="pulse"></span> Running';
  byId('statusBadge').className = 'badge badge-run';

  const vars = generateVariations(word, depth);
  stats.vars += vars.length;
  updateStats();

  addFeed(`ğŸ” "${word}" â€” ${vars.length} variations (${mode}, ${depth})`, 'fe-info');

  for (let i = 0; i < vars.length; i++) {
    if (stopCheck) break;

    const v = vars[i];
    setProgress(Math.round(i / vars.length * 100));

    let keyInfo, addrs;
    try {
      if (mode === 'brainwallet') {
        keyInfo = deriveBrainWallet(v);
        addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
      } else {
        keyInfo = await deriveBip39(v);
        addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.native];
      }
    } catch (e) {
      addFeed(`Error deriving "${v}": ${e.message}`, 'fe-error');
      continue;
    }

    addFeed(`Checking: "${v}"â€¦`, 'fe-checking');

    let bals;
    try {
      bals = await checkBalances(addrs);
    } catch (e) {
      updateLastFeed(`âš ï¸ API error for "${v}"`, 'fe-error');
      await sleep(1000);
      continue;
    }

    stats.addrs += addrs.length;

    let anyBal  = false;
    let anyUsed = false;
    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        anyBal = true;
        showResult(v, addr, info.balance, info.txCount, keyInfo);
        addFeed(`ğŸ† BALANCE: "${v}" â†’ ${addr} â€” ${info.balance.toFixed(8)} BTC`, 'fe-found');
      } else if (info.txCount > 0 && !anyBal) {
        anyUsed = true;
      }
    }

    if (!anyBal) {
      if (anyUsed) {
        updateLastFeed(`ğŸ‘ "${v}" â€” used (0 BTC, already swept)`, 'fe-used');
      } else {
        updateLastFeed(`âŒ "${v}" â€” empty`, 'fe-empty');
      }
    }

    stats.words++;
    updateStats();

    await sleep(mode === 'bip39' ? 600 : 250);
  }

  setProgress(100);
  addFeed(stopCheck
    ? `â¹ Stopped â€” ${stats.words} variations tried`
    : `âœ… Done â€” all ${vars.length} variations checked`,
    'fe-info'
  );

  isChecking = false;
  byId('btnCheck').classList.remove('hidden');
  byId('btnStop').classList.add('hidden');
  byId('statusBadge').textContent = 'â¸ Idle';
  byId('statusBadge').className = 'badge badge-idle';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RANDOM KEY HUNT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startHunt(count) {
  if (isHunting) return;
  isHunting = true;
  stopHunt  = false;

  ['bH10','bH100','bH1000'].forEach(id => byId(id).disabled = true);
  byId('bHStop').classList.remove('hidden');
  byId('bHStop').textContent = 'â¹ Stop';

  addHuntFeed(`ğŸ° Starting hunt â€” ${count} random keys`, 'fe-info');

  let thisFound = 0;

  for (let i = 0; i < count; i++) {
    if (stopHunt) break;

    const privBytes = crypto.getRandomValues(new Uint8Array(32));

    let pubC;
    try {
      pubC = secp256k1.getPublicKey(privBytes, true);
    } catch (_) {
      continue; // invalid scalar (astronomically rare)
    }

    const legacy = pubToLegacy(pubC);
    const native = pubToNative(pubC);

    addHuntFeed(`[${i + 1}/${count}] ${legacy.slice(0, 14)}â€¦ checkingâ€¦`, 'fe-checking');

    let bals;
    try {
      bals = await checkBalances([legacy, native]);
    } catch (_) {
      await sleep(500);
      continue;
    }

    stats.keys++;
    stats.addrs += 2;
    updateStats();

    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        thisFound++;
        const ki = { privHex: bytesToHex(privBytes), wif: toWIF(privBytes, true), wifU: toWIF(privBytes, false) };
        showResult(`RANDOM KEY #${stats.keys}`, addr, info.balance, info.txCount, ki);
        addHuntFeed(`ğŸ° JACKPOT! ${addr} â€” ${info.balance.toFixed(8)} BTC`, 'fe-jackpot');
      }
    }

    await sleep(420);
  }

  addHuntFeed(
    stopHunt
      ? `â¹ Hunt stopped â€” ${stats.keys} total keys hunted, ${thisFound} found this run`
      : `âœ… Complete â€” ${count} keys checked, ${thisFound} found`,
    'fe-info'
  );

  isHunting = false;
  ['bH10','bH100','bH1000'].forEach(id => byId(id).disabled = false);
  byId('bHStop').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BATCH MODE TOGGLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setBatchMode(m) {
  batchMode = m;
  byId('batchModeBW').classList.toggle('active',  m === 'brainwallet');
  byId('batchModeBIP').classList.toggle('active', m === 'bip39');
}
function setBatchDepth(d) {
  batchDepth = d;
  byId('batchDepthN').classList.toggle('active', d === 'normal');
  byId('batchDepthD').classList.toggle('active', d === 'deep');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BATCH CHECK FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startBatch() {
  const raw = byId('batchInput').value.trim();
  if (!raw) { showToast('Paste some words first'); return; }
  if (isBatching) return;

  const words = [...new Set(raw.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0 && w.length <= 80))];
  if (words.length === 0) { showToast('No valid words found'); return; }

  isBatching = true;
  stopBatchFlag = false;

  byId('btnBatchCheck').classList.add('hidden');
  byId('btnBatchStop').classList.remove('hidden');
  byId('btnBatchStop').textContent = 'â¹ Stop';
  byId('batchFeedCard').classList.remove('hidden');

  const feed = byId('batchFeed');
  feed.innerHTML = '';

  let wordsDone = 0;

  function batchFeedLine(msg, cls = 'fe-info') {
    const el = document.createElement('div');
    el.className = `feed-entry ${cls}`;
    el.textContent = `${ts()} ${msg}`;
    feed.appendChild(el);
    while (feed.children.length > 300) feed.removeChild(feed.firstChild);
    feed.scrollTop = feed.scrollHeight;
    return el;
  }
  function updateBatchLast(msg, cls) {
    const last = feed.lastElementChild;
    if (!last) return;
    last.className = `feed-entry ${cls}`;
    last.textContent = `${ts()} ${msg}`;
  }

  batchFeedLine(`ğŸ” Batch: ${words.length} words Â· mode=${batchMode} Â· depth=${batchDepth}`, 'fe-info');

  for (let wi = 0; wi < words.length; wi++) {
    if (stopBatchFlag) break;

    const word = words[wi];
    byId('batchProgress').textContent = `${wi + 1} / ${words.length}`;

    const pct = Math.round(wi / words.length * 100);
    byId('batchProgWrap').classList.remove('hidden');
    byId('batchProgBar').style.width = pct + '%';

    const vars = generateVariations(word, batchDepth);
    stats.vars += vars.length;

    for (let vi = 0; vi < vars.length; vi++) {
      if (stopBatchFlag) break;

      const v = vars[vi];
      let keyInfo, addrs;
      try {
        if (batchMode === 'brainwallet') {
          keyInfo = deriveBrainWallet(v);
          addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
        } else {
          keyInfo = await deriveBip39(v);
          addrs   = [keyInfo.addrs.legacyC, keyInfo.addrs.native];
        }
      } catch (e) { continue; }

      batchFeedLine(`[${wi+1}/${words.length}] "${v}"â€¦`, 'fe-checking');

      let bals;
      try { bals = await checkBalances(addrs); } catch(e) { await sleep(500); continue; }

      stats.addrs += addrs.length;

      let anyBal = false, anyUsed = false;
      for (const [addr, info] of Object.entries(bals)) {
        if (info.balance > 0) {
          anyBal = true;
          showResult(v, addr, info.balance, info.txCount, keyInfo);
          batchFeedLine(`ğŸ† FOUND: "${v}" â†’ ${info.balance.toFixed(8)} BTC`, 'fe-found');
        } else if (info.txCount > 0 && !anyBal) {
          anyUsed = true;
        }
      }
      if (!anyBal) {
        updateBatchLast(
          anyUsed ? `ğŸ‘ "${v}" â€” used (0 BTC, swept)` : `âŒ "${v}" â€” empty`,
          anyUsed ? 'fe-used' : 'fe-empty'
        );
      }

      stats.words++;
      updateStats();
      await sleep(batchMode === 'bip39' ? 600 : 250);
    }

    wordsDone++;
  }

  byId('batchProgBar').style.width = '100%';
  byId('batchProgress').textContent = `Done â€” ${wordsDone} words`;
  batchFeedLine(
    stopBatchFlag ? `â¹ Stopped â€” ${wordsDone} of ${words.length} words` : `âœ… Batch complete â€” ${words.length} words`,
    'fe-info'
  );

  isBatching = false;
  byId('btnBatchCheck').classList.remove('hidden');
  byId('btnBatchStop').classList.add('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD SHORTCUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
byId('wordInput').addEventListener('keydown', e => {
  if (e.key === 'Enter' && !isChecking) startCheck();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  URL PARAM DEEP LINKING â€” auto-fill & auto-start
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initFromUrlParams() {
  const params = new URLSearchParams(location.search);
  const word   = params.get('word');
  const words  = params.get('words');
  const modeP  = params.get('mode');
  const depthP = params.get('depth');
  const tab    = params.get('tab');

  // Apply mode / depth overrides first
  if (modeP === 'bip39' || modeP === 'brainwallet') {
    setMode(modeP);
    setBatchMode(modeP);
  }
  if (depthP === 'deep' || depthP === 'normal') {
    setDepth(depthP);
    setBatchDepth(depthP);
  }

  if (words) {
    // Batch tab: pre-fill textarea and auto-start
    switchTab('batch');
    byId('batchInput').value = words.replace(/,/g, '\n');
    byId('batchFeedCard').classList.remove('hidden');
    setTimeout(() => startBatch(), 700);

  } else if (word) {
    // Single word tab: pre-fill and auto-start
    switchTab('single');
    byId('wordInput').value = word;
    setTimeout(() => startCheck(), 500);

  } else if (tab === 'batch') {
    switchTab('batch');
  } else if (tab === 'hunt') {
    switchTab('hunt');
  } else if (tab === 'memory') {
    switchTab('memory');
  } else if (tab === 'ai') {
    switchTab('ai');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MEMORY GUIDE â€” DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MEM_TOPIC_WORDS = {
  gaming:  ['minecraft','warcraft','starcraft','skyrim','steam','halflife','counter','quake','doom','zelda','mario','sonic','pokemon','fortnite','wow','lol','halo','diablo','runescape'],
  movies:  ['matrix','batman','inception','avatar','titanic','darth','vader','jedi','sith','hobbit','harry','potter','stark','joker','avengers','godfather','gladiator','shrek','terminator'],
  sports:  ['football','soccer','basketball','messi','ronaldo','jordan','lakers','yankees','chelsea','barcelona','nfl','nba','champion','winner','trophy','referee','penalty','scoreboard'],
  music:   ['metallica','nirvana','beatles','eminem','skrillex','dubstep','guitar','piano','rockstar','metal','jazz','rapper','melody','linkin','park','radiohead','coldplay'],
  crypto:  ['bitcoin','satoshi','nakamoto','blockchain','halving','hodl','moon','lambo','defi','nft','mining','hash','genesis','block','crypto','btc','miner','wallet'],
  nature:  ['dragon','wolf','tiger','eagle','phoenix','lion','cobra','falcon','shark','thunder','storm','shadow','darkness','fire','ice','mountain','ocean','forest','thunder'],
  personal:['love','family','forever','secret','lucky','dream','hope','angel','heart','faith','trust','power','freedom','peace','victory','sunrise','destiny','spirit'],
  work:    ['admin','password','server','database','deploy','backend','devops','engineer','manager','office','project','system','network','cloud','docker','code','linux'],
};
const YEAR_WORDS = {
  '2009': ['genesis','satoshi','nakamoto','first','pioneer','bitcoin','original'],
  '2010': ['pizza','laszlo','hanyecz','exchange','dollar'],
  '2011': ['silk','road','wikileaks','anonymous'],
  '2012': ['halving','halvening'],
  '2013': ['cyprus','mtgox','silkroad','ross'],
  '2014': ['gox','collapse','ethereum','vitalik'],
  '2015': ['eth','ethereum','smart','contract'],
  '2016': ['dao','hack','fork','classic'],
  '2017': ['boom','altseason','ico','bull','moon','lambo'],
  '2018': ['crash','bear','market'],
  '2019': ['libra','facebook','bakkt','futures'],
  '2020': ['halving','pandemic','defi','summer'],
  '2021': ['nft','bull','ath','laser','eyes'],
  '2022': ['luna','ftx','crash','celsius'],
  '2023': ['etf','spot','approve'],
};
const COMMON_BRAIN_WALLETS = [
  'password','bitcoin','satoshi','1234','qwerty','test','hello','secret',
  'abc123','letmein','monkey','dragon','master','admin','welcome','login',
  'pass','love','money','freedom','matrix','blockchain','private','nakamoto',
  'god','correct horse battery staple','this is a test','to be or not to be',
  'bitcoin is freedom','the quick brown fox','i am satoshi nakamoto','genesis',
];

let memAnswers = { year: null, topic: null, platform: null, hint: '' };
let memStep    = 0;
let memWordList = [];
let aiWordList  = [];
let isLucky    = false;
let isAIGen    = false;
const checkedWordsSession = new Set();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MEMORY GUIDE â€” FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function memAnswer(key, value) {
  memAnswers[key] = value;
  document.querySelectorAll(`[data-mem="${key}"]`).forEach(b => {
    b.classList.toggle('active', b.dataset.val === String(value));
  });
  setTimeout(() => {
    if (key === 'year')     showMemStep(1);
    if (key === 'topic')    showMemStep(2);
    if (key === 'platform') showMemStep(3);
  }, 300);
}

function showMemStep(step) {
  memStep = step;
  for (let i = 0; i < 4; i++) {
    const p = byId(`memStep${i}`);
    if (p) p.classList.toggle('hidden', i !== step);
  }
  document.querySelectorAll('.step-dot').forEach((dot, i) => {
    dot.className = 'step-dot' + (i < step ? ' done' : i === step ? ' active' : '');
  });
}

function generateMemoryWords() {
  const words = new Set(COMMON_BRAIN_WALLETS.slice(0, 8));
  if (memAnswers.topic && MEM_TOPIC_WORDS[memAnswers.topic]) {
    MEM_TOPIC_WORDS[memAnswers.topic].forEach(w => words.add(w));
  }
  if (memAnswers.year && YEAR_WORDS[memAnswers.year]) {
    YEAR_WORDS[memAnswers.year].forEach(w => words.add(w));
    words.add(String(memAnswers.year));
  }
  if (memAnswers.hint) {
    memAnswers.hint.trim().split(/\s+/).forEach(w => { if (w.length > 0) words.add(w.toLowerCase()); });
  }
  if (memAnswers.platform === 'windows') {
    [...words].slice(0, 6).forEach(w => { words.add(w + '1'); words.add(w + '123'); });
  } else if (memAnswers.platform === 'mobile') {
    [...words].slice(0, 6).forEach(w => { words.add(w + '007'); words.add(w + '2021'); });
  }
  return [...words].filter(w => w.length > 0 && w.length <= 60);
}

function updateMemWordCloud() {
  memWordList = generateMemoryWords();
  const cloud = byId('memWordCloud');
  cloud.innerHTML = '';
  memWordList.forEach(w => {
    const tag = document.createElement('span');
    tag.className = 'mem-word-tag';
    tag.textContent = w;
    cloud.appendChild(tag);
  });
  byId('memWordCount').textContent = `${memWordList.length} words`;
  byId('memResultsSection').classList.remove('hidden');
}

function sendMemToBatch() {
  if (!memWordList.length) return;
  switchTab('batch');
  byId('batchInput').value = memWordList.join('\n');
  showToast(`âœ“ ${memWordList.length} memory words sent to Batch`);
}

function resetMemWizard() {
  memAnswers = { year: null, topic: null, platform: null, hint: '' };
  document.querySelectorAll('.mem-btn').forEach(b => b.classList.remove('active'));
  byId('memHintInput').value = '';
  byId('memResultsSection').classList.add('hidden');
  showMemStep(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FEELING LUCKY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function feelingLucky() {
  if (isLucky) return;
  isLucky = true;
  const luckyBtn = byId('btnLucky');
  luckyBtn.disabled = true;
  luckyBtn.textContent = 'ğŸ€ Checkingâ€¦';

  const candidates = [...new Set([
    ...COMMON_BRAIN_WALLETS,
    ...(memWordList.length ? memWordList : []),
    ...(aiWordList.length  ? aiWordList  : []),
  ])].filter(w => !checkedWordsSession.has(w)).slice(0, 12);

  const grid = byId('luckyGrid');
  grid.innerHTML = '';

  // Reveal cards one by one
  const cards = [];
  for (const w of candidates) {
    await sleep(70);
    const el = document.createElement('div');
    el.className = 'lucky-word';
    el.textContent = w;
    grid.appendChild(el);
    cards.push({ el, word: w });
  }

  await sleep(350);

  for (const { el, word } of cards) {
    el.classList.add('checking');
    el.textContent = `ğŸ” ${word}`;
    checkedWordsSession.add(word);

    let keyInfo, addrs;
    try {
      keyInfo = deriveBrainWallet(word);
      addrs = [keyInfo.addrs.legacyC, keyInfo.addrs.legacyU, keyInfo.addrs.p2sh, keyInfo.addrs.native];
    } catch (_) {
      el.classList.remove('checking'); el.classList.add('empty'); el.textContent = word; continue;
    }

    let bals;
    try { bals = await checkBalances(addrs); }
    catch (_) { el.classList.remove('checking'); el.classList.add('empty'); el.textContent = word; continue; }

    stats.addrs += addrs.length;
    stats.words++;
    updateStats();

    let found = false;
    for (const [addr, info] of Object.entries(bals)) {
      if (info.balance > 0) {
        found = true;
        showResult(word, addr, info.balance, info.txCount, keyInfo);
        el.classList.remove('checking'); el.classList.add('found');
        el.textContent = `ğŸ† ${word}`;
        showToast('ğŸ† Found a wallet!', 5000);
      }
    }
    if (!found) {
      const anyUsed = Object.values(bals).some(i => i.txCount > 0);
      el.classList.remove('checking');
      el.classList.add(anyUsed ? 'used' : 'empty');
      el.textContent = anyUsed ? `ğŸ‘ ${word}` : word;
    }
    await sleep(280);
  }

  isLucky = false;
  luckyBtn.disabled = false;
  luckyBtn.textContent = 'ğŸ€ Try Again';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AI SUGGEST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function detectAIProvider(val) {
  const badge = byId('aiProviderBadge');
  if (val.startsWith('gsk_')) {
    badge.textContent = 'âš¡ Groq (free)'; badge.style.color = 'var(--success)';
  } else if (val.startsWith('sk-')) {
    badge.textContent = 'ğŸ¤– OpenAI'; badge.style.color = 'var(--accent)';
  } else {
    badge.textContent = 'Auto-detect'; badge.style.color = '';
  }
}

async function callAI(apiKey, prompt, maxTokens = 400) {
  const isOpenAI = apiKey.startsWith('sk-') && !apiKey.startsWith('sk-gsk');
  const endpoint = isOpenAI
    ? 'https://api.openai.com/v1/chat/completions'
    : 'https://api.groq.com/openai/v1/chat/completions';
  const model = isOpenAI ? 'gpt-4o-mini' : 'llama-3.3-70b-versatile';

  const resp = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: maxTokens,
      temperature: 0.7,
    }),
    signal: AbortSignal.timeout(25000),
  });
  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`AI error ${resp.status}: ${err.slice(0, 120)}`);
  }
  return (await resp.json()).choices[0].message.content.trim();
}

async function generateAIWords() {
  const apiKey  = byId('aiApiKey').value.trim();
  const context = byId('aiContext').value.trim();
  if (!apiKey) { showToast('Enter a Groq or OpenAI API key first'); return; }
  if (isAIGen) return;
  isAIGen = true;

  const btn = byId('btnAIGenerate');
  btn.disabled = true;
  btn.textContent = 'â³ Generatingâ€¦';
  byId('aiWordCloud').innerHTML = '';
  byId('aiResultsSection').classList.add('hidden');

  const prompt = `You are helping recover a forgotten Bitcoin brain wallet passphrase.
Context from the wallet owner: ${context || 'general Bitcoin user from 2011-2017'}

Generate 25-35 candidate passphrases they might have used. Include:
- Common words/phrases related to the context
- Bitcoin-era slang and references
- Simple passwords with common modifications
- Names, places, or hobbies related to their context

Reply with ONLY a JSON array of strings, no explanation.
Example: ["word1","phrase two","another phrase"]`;

  try {
    const text = await callAI(apiKey, prompt);
    const match = text.match(/\[[\s\S]*\]/);
    if (!match) throw new Error('AI returned unexpected format');
    aiWordList = JSON.parse(match[0])
      .filter(w => typeof w === 'string' && w.length > 0 && w.length <= 80);

    const cloud = byId('aiWordCloud');
    cloud.innerHTML = '';
    aiWordList.forEach(w => {
      const tag = document.createElement('span');
      tag.className = 'ai-word-tag';
      tag.textContent = w;
      cloud.appendChild(tag);
    });
    byId('aiWordCount').textContent = `${aiWordList.length} words`;
    byId('aiResultsSection').classList.remove('hidden');
    showToast(`âœ“ AI generated ${aiWordList.length} candidates`);
  } catch (e) {
    showToast(`âŒ ${e.message.slice(0, 70)}`);
  }

  isAIGen = false;
  btn.disabled = false;
  btn.textContent = 'ğŸ¤– Generate Words';
}

function sendAIToBatch() {
  if (!aiWordList.length) return;
  switchTab('batch');
  byId('batchInput').value = aiWordList.join('\n');
  showToast(`âœ“ ${aiWordList.length} AI words sent to Batch`);
}

// â”€â”€â”€ INIT â”€â”€â”€
updateStats();
initFromUrlParams();
</script>
</body>
</html>
